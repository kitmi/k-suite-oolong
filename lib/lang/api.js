"use strict";

require("source-map-support/register");

const path = require('path');

const Util = require('rk-utils');

const {
  _,
  fs,
  eachAsync_
} = Util;

const Linker = require('./Linker');

const Connector = require('../runtime/Connector');

const Validators = require('../runtime/Validators');

function createConnector(context, schemaName) {
  let deployment = context.schemaDeployment[schemaName];

  if (!deployment) {
    throw new Error(`Schema "${schemaName}" has no configured deployment and is ignored in modeling.`);
  }

  let {
    dataSource,
    connectionString,
    options
  } = deployment;
  let [driver] = dataSource.split('.');
  return Connector.createConnector(driver, connectionString, {
    logger: context.logger,
    ...options
  });
}

async function importDataFiles(migrator, folderName) {
  let dataSetPath = path.join(migrator.dbScriptPath, 'data', folderName);
  let dataListFile = path.join(dataSetPath, 'index.list');

  if (!fs.existsSync(dataListFile)) {
    throw new Error(`Entry file of dataset "${folderName}" not found.`);
  }

  let dataList = fs.readFileSync(dataListFile).toString().match(/^.+$/gm);
  return eachAsync_(dataList, async line => {
    line = line.trim();

    if (line.length > 0) {
      let dataFile = path.join(dataSetPath, line);

      if (!fs.existsSync(dataFile)) {
        throw new Error(`Data file "${dataFile}" not found.`);
      }

      await migrator.load_(dataFile);
    }
  });
}

exports.build_ = async context => {
  context.logger.log('verbose', 'Start building models ...');
  let linker = new Linker(context);
  context.linker = linker;
  let schemaFiles = Linker.getOolongFiles(context.dslSourcePath, context.useJsonSource);
  schemaFiles.forEach(schemaFile => linker.link(schemaFile));

  let schemaToConnector = _.mapValues(linker.schemas, (_, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    return connector;
  });

  return eachAsync_(context.schemaDeployment, async (deploymentSetting, schemaName) => {
    context.logger.log('verbose', `Processing schema "${schemaName}" ...`);
    let schema = linker.schemas[schemaName];

    if (!schema) {
      throw new Error(`Schema "${schemaName}" not found in model source."`);
    }

    let connector = schemaToConnector[schemaName];

    try {
      let DbModeler = require(`../modeler/database/${connector.driver}/Modeler`);

      let dbModeler = new DbModeler(context, connector, deploymentSetting.extraOptions);
      let refinedSchema = dbModeler.modeling(schema, schemaToConnector);

      const DaoModeler = require('../modeler/Dao');

      let daoModeler = new DaoModeler(context, connector);
      await daoModeler.modeling_(refinedSchema);
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.migrate_ = async (context, reset = false) => {
  context.logger.log('verbose', 'Start deploying models ...');

  if (reset) {
    await eachAsync_(Object.keys(context.schemaDeployment).reverse(), async schemaName => {
      let connector = createConnector(context, schemaName);

      if (!connector) {
        throw new Error("Assertion failed: connector");
      }

      try {
        let Migration = require(`../migration/${connector.driver}`);

        let migration = new Migration(context, schemaName, connector);
        await migration.reset_();
      } catch (error) {
        throw error;
      } finally {
        await connector.end_();
      }
    });
  }

  return eachAsync_(context.schemaDeployment, async (deployment, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    try {
      let Migration = require(`../migration/${connector.driver}`);

      let migration = new Migration(context, schemaName, connector);
      await migration.create_(deployment.extraOptions);
      await importDataFiles(migration, '_init');
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.dataset_ = async (context, schemaName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  let dataSetPath = path.join(context.scriptSourcePath, connector.driver, connector.database, 'data');

  if (!fs.existsSync(dataSetPath)) {
    return [];
  } else {
    let dataSets = fs.readdirSync(dataSetPath);
    let validDs = [];
    dataSets.forEach(ds => {
      let indexFile = path.join(dataSetPath, ds, 'index.list');

      if (fs.existsSync(indexFile)) {
        validDs.push(ds);
      }
    });
    return validDs;
  }
};

exports.import_ = async (context, schemaName, datasetName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let Migration = require(`../migration/${connector.driver}`);

    let migration = new Migration(context, schemaName, connector);
    await importDataFiles(migration, datasetName);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.reverse_ = async context => {
  let ReserveEngineering = require(`../modeler/database/${context.driver}/ReverseEngineering`);

  let {
    connection: connectionString,
    ...options
  } = context.connOptions;
  let connector = Connector.createConnector(context.driver, connectionString, {
    logger: context.logger,
    ...options
  });

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let modeler = new ReserveEngineering(context, connector);
    await modeler.reverse_(context.dslReverseOutputPath);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.getValidatorList = () => {
  return Object.keys(Validators);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYW5nL2FwaS5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIlV0aWwiLCJfIiwiZnMiLCJlYWNoQXN5bmNfIiwiTGlua2VyIiwiQ29ubmVjdG9yIiwiVmFsaWRhdG9ycyIsImNyZWF0ZUNvbm5lY3RvciIsImNvbnRleHQiLCJzY2hlbWFOYW1lIiwiZGVwbG95bWVudCIsInNjaGVtYURlcGxveW1lbnQiLCJFcnJvciIsImRhdGFTb3VyY2UiLCJjb25uZWN0aW9uU3RyaW5nIiwib3B0aW9ucyIsImRyaXZlciIsInNwbGl0IiwibG9nZ2VyIiwiaW1wb3J0RGF0YUZpbGVzIiwibWlncmF0b3IiLCJmb2xkZXJOYW1lIiwiZGF0YVNldFBhdGgiLCJqb2luIiwiZGJTY3JpcHRQYXRoIiwiZGF0YUxpc3RGaWxlIiwiZXhpc3RzU3luYyIsImRhdGFMaXN0IiwicmVhZEZpbGVTeW5jIiwidG9TdHJpbmciLCJtYXRjaCIsImxpbmUiLCJ0cmltIiwibGVuZ3RoIiwiZGF0YUZpbGUiLCJsb2FkXyIsImV4cG9ydHMiLCJidWlsZF8iLCJsb2ciLCJsaW5rZXIiLCJzY2hlbWFGaWxlcyIsImdldE9vbG9uZ0ZpbGVzIiwiZHNsU291cmNlUGF0aCIsInVzZUpzb25Tb3VyY2UiLCJmb3JFYWNoIiwic2NoZW1hRmlsZSIsImxpbmsiLCJzY2hlbWFUb0Nvbm5lY3RvciIsIm1hcFZhbHVlcyIsInNjaGVtYXMiLCJjb25uZWN0b3IiLCJkZXBsb3ltZW50U2V0dGluZyIsInNjaGVtYSIsIkRiTW9kZWxlciIsImRiTW9kZWxlciIsImV4dHJhT3B0aW9ucyIsInJlZmluZWRTY2hlbWEiLCJtb2RlbGluZyIsIkRhb01vZGVsZXIiLCJkYW9Nb2RlbGVyIiwibW9kZWxpbmdfIiwiZXJyb3IiLCJlbmRfIiwibWlncmF0ZV8iLCJyZXNldCIsIk9iamVjdCIsImtleXMiLCJyZXZlcnNlIiwiTWlncmF0aW9uIiwibWlncmF0aW9uIiwicmVzZXRfIiwiY3JlYXRlXyIsImRhdGFzZXRfIiwic2NyaXB0U291cmNlUGF0aCIsImRhdGFiYXNlIiwiZGF0YVNldHMiLCJyZWFkZGlyU3luYyIsInZhbGlkRHMiLCJkcyIsImluZGV4RmlsZSIsInB1c2giLCJpbXBvcnRfIiwiZGF0YXNldE5hbWUiLCJyZXZlcnNlXyIsIlJlc2VydmVFbmdpbmVlcmluZyIsImNvbm5lY3Rpb24iLCJjb25uT3B0aW9ucyIsIm1vZGVsZXIiLCJkc2xSZXZlcnNlT3V0cHV0UGF0aCIsImdldFZhbGlkYXRvckxpc3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUEsTUFBTUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFFQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxVQUFELENBQXBCOztBQUNBLE1BQU07QUFBRUUsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQSxFQUFMO0FBQVNDLEVBQUFBO0FBQVQsSUFBd0JILElBQTlCOztBQUVBLE1BQU1JLE1BQU0sR0FBR0wsT0FBTyxDQUFDLFVBQUQsQ0FBdEI7O0FBQ0EsTUFBTU0sU0FBUyxHQUFHTixPQUFPLENBQUMsc0JBQUQsQ0FBekI7O0FBQ0EsTUFBTU8sVUFBVSxHQUFHUCxPQUFPLENBQUMsdUJBQUQsQ0FBMUI7O0FBT0MsU0FBU1EsZUFBVCxDQUF5QkMsT0FBekIsRUFBa0NDLFVBQWxDLEVBQThDO0FBQzNDLE1BQUlDLFVBQVUsR0FBR0YsT0FBTyxDQUFDRyxnQkFBUixDQUF5QkYsVUFBekIsQ0FBakI7O0FBRUEsTUFBSSxDQUFDQyxVQUFMLEVBQWlCO0FBQ2IsVUFBTSxJQUFJRSxLQUFKLENBQVcsV0FBVUgsVUFBVyw0REFBaEMsQ0FBTjtBQUNIOztBQUVELE1BQUk7QUFBRUksSUFBQUEsVUFBRjtBQUFjQyxJQUFBQSxnQkFBZDtBQUFnQ0MsSUFBQUE7QUFBaEMsTUFBNENMLFVBQWhEO0FBQ0EsTUFBSSxDQUFFTSxNQUFGLElBQWFILFVBQVUsQ0FBQ0ksS0FBWCxDQUFpQixHQUFqQixDQUFqQjtBQUVBLFNBQU9aLFNBQVMsQ0FBQ0Us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QU47QUFDSCxHQUpELENBSUUsT0FBTzNCLEtBQVAsRUFBYztBQUNaLFVBQU1BLEtBQU47QUFDSCxHQU5ELFNBTVU7QUFDTixVQUFNWCxTQUFTLENBQUNZLElBQVYsRUFBTjtBQUNIO0FBQ0osQ0FoQkQ7O0FBa0JBMUIsT0FBTyxDQUFDcUQsZ0JBQVIsR0FBMkIsTUFBTTtBQUM3QixTQUFPeEIsTUFBTSxDQUFDQyxJQUFQLENBQVk1RCxVQUFaLENBQVA7QUFDSCxDQUZEIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IFV0aWwgPSByZXF1aXJlKCdyay11dGlscycpO1xuY29uc3QgeyBfLCBmcywgZWFjaEFzeW5jXyB9ID0gVXRpbDtcblxuY29uc3QgTGlua2VyID0gcmVxdWlyZSgnLi9MaW5rZXInKTtcbmNvbnN0IENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvQ29ubmVjdG9yJyk7XG5jb25zdCBWYWxpZGF0b3JzID0gcmVxdWlyZSgnLi4vcnVudGltZS9WYWxpZGF0b3JzJyk7XG5cbi8qKlxuICogT29sb25nIERTTCBhcGlcbiAqIEBtb2R1bGUgT29sb25nXG4gKi9cblxuIGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKSB7XG4gICAgbGV0IGRlcGxveW1lbnQgPSBjb250ZXh0LnNjaGVtYURlcGxveW1lbnRbc2NoZW1hTmFtZV07XG5cbiAgICBpZiAoIWRlcGxveW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY2hlbWEgXCIke3NjaGVtYU5hbWV9XCIgaGFzIG5vIGNvbmZpZ3VyZWQgZGVwbG95bWVudCBhbmQgaXMgaWdub3JlZCBpbiBtb2RlbGluZy5gKTtcbiAgICB9XG5cbiAgICBsZXQgeyBkYXRhU291cmNlLCBjb25uZWN0aW9uU3RyaW5nLCBvcHRpb25zIH0gPSBkZXBsb3ltZW50O1xuICAgIGxldCBbIGRyaXZlciBdID0gZGF0YVNvdXJjZS5zcGxpdCgnLicpO1xuXG4gICAgcmV0dXJuIENvbm5lY3Rvci5jcmVhdGVDb25uZWN0b3IoZHJpdmVyLCBjb25uZWN0aW9uU3RyaW5nLCB7IGxvZ2dlcjogY29udGV4dC5sb2dnZXIsIC4uLm9wdGlvbnMgfSk7ICAgICAgIFxuIH1cblxuIGFzeW5jIGZ1bmN0aW9uIGltcG9ydERhdGFGaWxlcyhtaWdyYXRvciwgZm9sZGVyTmFtZSkge1xuICAgIGxldCBkYXRhU2V0UGF0aCA9IHBhdGguam9pbihtaWdyYXRvci5kYlNjcmlwdFBhdGgsICdkYXRhJywgZm9sZGVyTmFtZSk7XG4gICAgbGV0IGRhdGFMaXN0RmlsZSA9IHBhdGguam9pbihkYXRhU2V0UGF0aCwgJ2luZGV4Lmxpc3QnKTtcblxuICAgIGlmICghZnMuZXhpc3RzU3luYyhkYXRhTGlzdEZpbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW50cnkgZmlsZSBvZiBkYXRhc2V0IFwiJHtmb2xkZXJOYW1lfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YUxpc3QgPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUxpc3RGaWxlKS50b1N0cmluZygpLm1hdGNoKC9eLiskL2dtKTtcblxuICAgIHJldHVybiBlYWNoQXN5bmNfKGRhdGFMaXN0LCBhc3luYyBsaW5lID0+IHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBkYXRhRmlsZSA9IHBhdGguam9pbihkYXRhU2V0UGF0aCwgbGluZSk7XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGF0YUZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIGZpbGUgXCIke2RhdGFGaWxlfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgbWlncmF0b3IubG9hZF8oZGF0YUZpbGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gfVxuXG4vKipcbiAqIEJ1aWxkIGRhdGFiYXNlIHNjcmlwdHMgYW5kIGVudGl0eSBtb2RlbHMgZnJvbSBvb2xvbmcgZmlsZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHByb3BlcnR5IHtMb2dnZXJ9IGNvbnRleHQubG9nZ2VyIC0gTG9nZ2VyIG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuZHNsU291cmNlUGF0aFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQubW9kZWxPdXRwdXRQYXRoICAgICAgICAgXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5zY3JpcHRPdXRwdXRQYXRoXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5tYW5pZmVzdE91dHB1dFBhdGhcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gY29udGV4dC51c2VKc29uU291cmNlXG4gKiBAcHJvcGVydHkge29iamVjdH0gY29udGV4dC5zY2hlbWFEZXBsb3ltZW50ICAgXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0cy5idWlsZF8gPSBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgIGNvbnRleHQubG9nZ2VyLmxvZygndmVyYm9zZScsICdTdGFydCBidWlsZGluZyBtb2RlbHMgLi4uJyk7XG5cbiAgICBsZXQgbGlua2VyID0gbmV3IExpbmtlcihjb250ZXh0KTtcbiAgICBjb250ZXh0LmxpbmtlciA9IGxpbmtlcjsgICAgXG5cbiAgICBsZXQgc2NoZW1hRmlsZXMgPSBMaW5rZXIuZ2V0T29sb25nRmlsZXMoY29udGV4dC5kc2xTb3VyY2VQYXRoLCBjb250ZXh0LnVzZUpzb25Tb3VyY2UpO1xuICAgIHNjaGVtYUZpbGVzLmZvckVhY2goc2NoZW1hRmlsZSA9PiBsaW5rZXIubGluayhzY2hlbWFGaWxlKSk7ICBcbiAgICBcbiAgICBsZXQgc2NoZW1hVG9Db25uZWN0b3IgPSBfLm1hcFZhbHVlcyhsaW5rZXIuc2NoZW1hcywgKF8sIHNjaGVtYU5hbWUpID0+IHtcbiAgICAgICAgbGV0IGNvbm5lY3RvciA9IGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKTtcbiAgICAgICAgYXNzZXJ0OiBjb25uZWN0b3I7XG5cbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcbiAgICB9KTsgICAgXG5cbiAgICByZXR1cm4gZWFjaEFzeW5jXyhjb250ZXh0LnNjaGVtYURlcGxveW1lbnQsIGFzeW5jIChkZXBsb3ltZW50U2V0dGluZywgc2NoZW1hTmFtZSkgPT4geyAgICAgIFxuICAgICAgICBjb250ZXh0LmxvZ2dlci5sb2coJ3ZlcmJvc2UnLCBgUHJvY2Vzc2luZyBzY2hlbWEgXCIke3NjaGVtYU5hbWV9XCIgLi4uYCk7ICAgXG4gICAgICAgIFxuICAgICAgICBsZXQgc2NoZW1hID0gbGlua2VyLnNjaGVtYXNbc2NoZW1hTmFtZV07XG5cbiAgICAgICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiIG5vdCBmb3VuZCBpbiBtb2RlbCBzb3VyY2UuXCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBzY2hlbWFUb0Nvbm5lY3RvcltzY2hlbWFOYW1lXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IERiTW9kZWxlciA9IHJlcXVpcmUoYC4uL21vZGVsZXIvZGF0YWJhc2UvJHtjb25uZWN0b3IuZHJpdmVyfS9Nb2RlbGVyYCk7XG4gICAgICAgICAgICBsZXQgZGJNb2RlbGVyID0gbmV3IERiTW9kZWxlcihjb250ZXh0LCBjb25uZWN0b3IsIGRlcGxveW1lbnRTZXR0aW5nLmV4dHJhT3B0aW9ucyk7XG4gICAgICAgICAgICBsZXQgcmVmaW5lZFNjaGVtYSA9IGRiTW9kZWxlci5tb2RlbGluZyhzY2hlbWEsIHNjaGVtYVRvQ29ubmVjdG9yKTtcblxuICAgICAgICAgICAgY29uc3QgRGFvTW9kZWxlciA9IHJlcXVpcmUoJy4uL21vZGVsZXIvRGFvJyk7XG4gICAgICAgICAgICBsZXQgZGFvTW9kZWxlciA9IG5ldyBEYW9Nb2RlbGVyKGNvbnRleHQsIGNvbm5lY3Rvcik7XG5cbiAgICAgICAgICAgIGF3YWl0IGRhb01vZGVsZXIubW9kZWxpbmdfKHJlZmluZWRTY2hlbWEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgICAgICB9IFxuICAgIH0pOyAgICAgICAgICAgIFxufTtcblxuLyoqXG4gKiBEZXBsb3kgZGF0YWJhc2Ugc2NyaXB0cyBpbnRvIGRhdGFiYXNlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyfSBjb250ZXh0LmxvZ2dlciAtIExvZ2dlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0Lm1vZGVsUGF0aFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuZHNsU291cmNlUGF0aCBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LnNjcmlwdFNvdXJjZVBhdGggXG4gKiBAcHJvcGVydHkge29iamVjdH0gY29udGV4dC5zY2hlbWFEZXBsb3ltZW50ICAgXG4gKiBAcGFyYW0ge2Jvb2x9IHJlc2V0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0cy5taWdyYXRlXyA9IGFzeW5jIChjb250ZXh0LCByZXNldCA9IGZhbHNlKSA9PiB7XG4gICAgY29udGV4dC5sb2dnZXIubG9nKCd2ZXJib3NlJywgJ1N0YXJ0IGRlcGxveWluZyBtb2RlbHMgLi4uJyk7XG5cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgYXdhaXQgZWFjaEFzeW5jXyhPYmplY3Qua2V5cyhjb250ZXh0LnNjaGVtYURlcGxveW1lbnQpLnJldmVyc2UoKSwgYXN5bmMgKHNjaGVtYU5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQ6IGNvbm5lY3RvcjtcbiAgICBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IE1pZ3JhdGlvbiA9IHJlcXVpcmUoYC4uL21pZ3JhdGlvbi8ke2Nvbm5lY3Rvci5kcml2ZXJ9YCk7XG4gICAgICAgICAgICAgICAgbGV0IG1pZ3JhdGlvbiA9IG5ldyBNaWdyYXRpb24oY29udGV4dCwgc2NoZW1hTmFtZSwgY29ubmVjdG9yKTtcbiAgICBcbiAgICAgICAgICAgICAgICBhd2FpdCBtaWdyYXRpb24ucmVzZXRfKCk7ICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGVhY2hBc3luY18oY29udGV4dC5zY2hlbWFEZXBsb3ltZW50LCBhc3luYyAoZGVwbG95bWVudCwgc2NoZW1hTmFtZSkgPT4ge1xuICAgICAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgICAgICBhc3NlcnQ6IGNvbm5lY3RvcjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IE1pZ3JhdGlvbiA9IHJlcXVpcmUoYC4uL21pZ3JhdGlvbi8ke2Nvbm5lY3Rvci5kcml2ZXJ9YCk7XG4gICAgICAgICAgICBsZXQgbWlncmF0aW9uID0gbmV3IE1pZ3JhdGlvbihjb250ZXh0LCBzY2hlbWFOYW1lLCBjb25uZWN0b3IpO1xuXG4gICAgICAgICAgICBhd2FpdCBtaWdyYXRpb24uY3JlYXRlXyhkZXBsb3ltZW50LmV4dHJhT3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGF3YWl0IGltcG9ydERhdGFGaWxlcyhtaWdyYXRpb24sICdfaW5pdCcpOyAgICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgICAgICB9IFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYU5hbWVcbiAqL1xuZXhwb3J0cy5kYXRhc2V0XyA9IGFzeW5jIChjb250ZXh0LCBzY2hlbWFOYW1lKSA9PiB7XG4gICAgbGV0IGNvbm5lY3RvciA9IGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKTtcbiAgICBhc3NlcnQ6IGNvbm5lY3RvcjtcbiAgICBcbiAgICBsZXQgZGF0YVNldFBhdGggPSBwYXRoLmpvaW4oY29udGV4dC5zY3JpcHRTb3VyY2VQYXRoLCBjb25uZWN0b3IuZHJpdmVyLCBjb25uZWN0b3IuZGF0YWJhc2UsICdkYXRhJyk7XG5cbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGF0YVNldFBhdGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGF0YVNldHMgPSBmcy5yZWFkZGlyU3luYyhkYXRhU2V0UGF0aCk7XG4gICAgICAgIGxldCB2YWxpZERzID0gW107XG4gICAgICAgIGRhdGFTZXRzLmZvckVhY2goZHMgPT4ge1xuICAgICAgICAgICAgbGV0IGluZGV4RmlsZSA9IHBhdGguam9pbihkYXRhU2V0UGF0aCwgZHMsICdpbmRleC5saXN0Jyk7XG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhpbmRleEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWREcy5wdXNoKGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkRHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEltcG9ydCBhIGRhdGEgc2V0IGludG8gZGF0YWJhc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gKiBAcHJvcGVydHkge0xvZ2dlcn0gY29udGV4dC5sb2dnZXIgLSBMb2dnZXIgb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5zY3JpcHRTb3VyY2VQYXRoICBcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWFOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldE5hbWVcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5leHBvcnRzLmltcG9ydF8gPSBhc3luYyAoY29udGV4dCwgc2NoZW1hTmFtZSwgZGF0YXNldE5hbWUpID0+IHtcbiAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgIGFzc2VydDogY29ubmVjdG9yO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIGxldCBNaWdyYXRpb24gPSByZXF1aXJlKGAuLi9taWdyYXRpb24vJHtjb25uZWN0b3IuZHJpdmVyfWApO1xuICAgICAgICBsZXQgbWlncmF0aW9uID0gbmV3IE1pZ3JhdGlvbihjb250ZXh0LCBzY2hlbWFOYW1lLCBjb25uZWN0b3IpO1xuXG4gICAgICAgIGF3YWl0IGltcG9ydERhdGFGaWxlcyhtaWdyYXRpb24sIGRhdGFzZXROYW1lKTsgICAgICAgICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgIH0gXG59O1xuXG4vKipcbiAqIEV4dHJhY3QgZGF0YWJhc2Ugc3RydWN0dXJlIGludG8gb29sb25nIGRzbFxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7Q29ubmVjdG9yfSBjb250ZXh0LmNvbm5lY3RvclxuICogQHByb3BlcnR5IHtMb2dnZXJ9IGNvbnRleHQubG9nZ2VyIFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuZHNsUmV2ZXJzZU91dHB1dFBhdGggXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5kcml2ZXJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb250ZXh0LmNvbm5PcHRpb25zIFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMucmV2ZXJzZV8gPSBhc3luYyAoY29udGV4dCkgPT4geyAgIFxuICAgIGxldCBSZXNlcnZlRW5naW5lZXJpbmcgPSByZXF1aXJlKGAuLi9tb2RlbGVyL2RhdGFiYXNlLyR7Y29udGV4dC5kcml2ZXJ9L1JldmVyc2VFbmdpbmVlcmluZ2ApO1xuICAgIFxuICAgIGxldCB7IGNvbm5lY3Rpb246IGNvbm5lY3Rpb25TdHJpbmcsIC4uLm9wdGlvbnMgfSA9IGNvbnRleHQuY29ubk9wdGlvbnM7ICBcbiAgICBsZXQgY29ubmVjdG9yID0gQ29ubmVjdG9yLmNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LmRyaXZlciwgY29ubmVjdGlvblN0cmluZywgeyBsb2dnZXI6IGNvbnRleHQubG9nZ2VyLCAuLi5vcHRpb25zIH0pOyAgICAgXG4gICAgYXNzZXJ0OiBjb25uZWN0b3I7ICBcblxuICAgIHRyeSB7XG4gICAgICAgIGxldCBtb2RlbGVyID0gbmV3IFJlc2VydmVFbmdpbmVlcmluZyhjb250ZXh0LCBjb25uZWN0b3IpO1xuXG4gICAgICAgIGF3YWl0IG1vZGVsZXIucmV2ZXJzZV8oY29udGV4dC5kc2xSZXZlcnNlT3V0cHV0UGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICB9IFxufTtcblxuZXhwb3J0cy5nZXRWYWxpZGF0b3JMaXN0ID0gKCkgPT4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhWYWxpZGF0b3JzKTsgICAgXG59Il19