"use strict";

require("source-map-support/register");

const path = require('path');

const Util = require('rk-utils');

const {
  _,
  fs,
  eachAsync_
} = Util;

const Linker = require('./Linker');

const Connector = require('../runtime/Connector');

const Validators = require('../runtime/Validators');

function createConnector(context, schemaName) {
  let deployment = context.schemaDeployment[schemaName];

  if (!deployment) {
    throw new Error(`Schema "${schemaName}" has no configured deployment and is ignored in modeling.`);
  }

  let {
    dataSource,
    connectionString,
    options
  } = deployment;
  let [driver] = dataSource.split('.');
  return Connector.createConnector(driver, connectionString, {
    logger: context.logger,
    ...options
  });
}

async function importDataFiles(migrator, folderName) {
  let dataSetPath = path.join(migrator.dbScriptPath, 'data', folderName);
  let dataListFile = path.join(dataSetPath, 'index.list');

  if (!fs.existsSync(dataListFile)) {
    throw new Error(`Entry file of dataset "${folderName}" not found.`);
  }

  let dataList = fs.readFileSync(dataListFile).toString().match(/^.+$/gm);

  if (!dataList) {
    return;
  }

  return eachAsync_(dataList, async line => {
    line = line.trim();

    if (line.length > 0) {
      let dataFile = path.join(dataSetPath, line);

      if (!fs.existsSync(dataFile)) {
        throw new Error(`Data file "${dataFile}" not found.`);
      }

      await migrator.load_(dataFile);
    }
  });
}

exports.build_ = async context => {
  context.logger.log('verbose', 'Start building models ...');
  let linker = new Linker(context);
  context.linker = linker;
  let schemaFiles = Linker.getOolongFiles(context.dslSourcePath, context.useJsonSource);
  schemaFiles.forEach(schemaFile => linker.link(schemaFile));

  let schemaToConnector = _.mapValues(linker.schemas, (_, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    return connector;
  });

  return eachAsync_(context.schemaDeployment, async (deploymentSetting, schemaName) => {
    context.logger.log('verbose', `Processing schema "${schemaName}" ...`);
    let schema = linker.schemas[schemaName];

    if (!schema) {
      throw new Error(`Schema "${schemaName}" not found in model source."`);
    }

    let connector = schemaToConnector[schemaName];

    try {
      let DbModeler = require(`../modeler/database/${connector.driver}/Modeler`);

      let dbModeler = new DbModeler(context, connector, deploymentSetting.extraOptions);
      let refinedSchema = dbModeler.modeling(schema, schemaToConnector);

      const DaoModeler = require('../modeler/Dao');

      let daoModeler = new DaoModeler(context, connector);
      await daoModeler.modeling_(refinedSchema);
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.migrate_ = async (context, reset = false) => {
  context.logger.log('verbose', 'Start deploying models ...');

  if (reset) {
    await eachAsync_(Object.keys(context.schemaDeployment).reverse(), async schemaName => {
      let connector = createConnector(context, schemaName);

      if (!connector) {
        throw new Error("Assertion failed: connector");
      }

      try {
        let Migration = require(`../migration/${connector.driver}`);

        let migration = new Migration(context, schemaName, connector);
        await migration.reset_();
      } catch (error) {
        throw error;
      } finally {
        await connector.end_();
      }
    });
  }

  return eachAsync_(context.schemaDeployment, async (deployment, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    try {
      let Migration = require(`../migration/${connector.driver}`);

      let migration = new Migration(context, schemaName, connector);
      await migration.create_(deployment.extraOptions);
      await importDataFiles(migration, '_init');
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.dataset_ = async (context, schemaName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  let dataSetPath = path.join(context.scriptSourcePath, connector.driver, connector.database, 'data');

  if (!fs.existsSync(dataSetPath)) {
    return [];
  } else {
    let dataSets = fs.readdirSync(dataSetPath);
    let validDs = [];
    dataSets.forEach(ds => {
      let indexFile = path.join(dataSetPath, ds, 'index.list');

      if (fs.existsSync(indexFile)) {
        validDs.push(ds);
      }
    });
    return validDs;
  }
};

exports.import_ = async (context, schemaName, datasetName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let Migration = require(`../migration/${connector.driver}`);

    let migration = new Migration(context, schemaName, connector);
    await importDataFiles(migration, datasetName);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.reverse_ = async context => {
  let ReserveEngineering = require(`../modeler/database/${context.driver}/ReverseEngineering`);

  let {
    connection: connectionString,
    ...options
  } = context.connOptions;
  let connector = Connector.createConnector(context.driver, connectionString, {
    logger: context.logger,
    ...options
  });

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let modeler = new ReserveEngineering(context, connector);
    await modeler.reverse_(context.dslReverseOutputPath);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.getValidatorList = () => {
  return Object.keys(Validators);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYW5nL2FwaS5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIlV0aWwiLCJfIiwiZnMiLCJlYWNoQXN5bmNfIiwiTGlua2VyIiwiQ29ubmVjdG9yIiwiVmFsaWRhdG9ycyIsImNyZWF0ZUNvbm5lY3RvciIsImNvbnRleHQiLCJzY2hlbWFOYW1lIiwiZGVwbG95bWVudCIsInNjaGVtYURlcGxveW1lbnQiLCJFcnJvciIsImRhdGFTb3VyY2UiLCJjb25uZWN0aW9uU3RyaW5nIiwib3B0aW9ucyIsImRyaXZlciIsInNwbGl0IiwibG9nZ2VyIiwiaW1wb3J0RGF0YUZpbGVzIiwibWlncmF0b3IiLCJmb2xkZXJOYW1lIiwiZGF0YVNldFBhdGgiLCJqb2luIiwiZGJTY3JpcHRQYXRoIiwiZGF0YUxpc3RGaWxlIiwiZXhpc3RzU3luYyIsImRhdGFMaXN0IiwicmVhZEZpbGVTeW5jIiwidG9TdHJpbmciLCJtYXRjaCIsImxpbmUiLCJ0cmltIiwibGVuZ3RoIiwiZGF0YUZpbGUiLCJsb2FkXyIsImV4cG9ydHMiLCJidWlsZF8iLCJsb2ciLCJsaW5rZXIiLCJzY2hlbWFGaWxlcyIsImdldE9vbG9uZ0ZpbGVzIiwiZHNsU291cmNlUGF0aCIsInVzZUpzb25Tb3VyY2UiLCJmb3JFYWNoIiwic2NoZW1hRmlsZSIsImxpbmsiLCJzY2hlbWFUb0Nvbm5lY3RvciIsIm1hcFZhbHVlcyIsInNjaGVtYXMiLCJjb25uZWN0b3IiLCJkZXBsb3ltZW50U2V0dGluZyIsInNjaGVtYSIsIkRiTW9kZWxlciIsImRiTW9kZWxlciIsImV4dHJhT3B0aW9ucyIsInJlZmluZWRTY2hlbWEiLCJtb2RlbGluZyIsIkRhb01vZGVsZXIiLCJkYW9Nb2RlbGVyIiwibW9kZWxpbmdfIiwiZXJyb3IiLCJlbmRfIiwibWlncmF0ZV8iLCJyZXNldCIsIk9iamVjdCIsImtleXMiLCJyZXZlcnNlIiwiTWlncmF0aW9uIiwibWlncmF0aW9uIiwicmVzZXRfIiwiY3JlYXRlXyIsImRhdGFzZXRfIiwic2NyaXB0U291cmNlUGF0aCIsImRhdGFiYXNlIiwiZGF0YVNldHMiLCJyZWFkZGlyU3luYyIsInZhbGlkRHMiLCJkcyIsImluZGV4RmlsZSIsInB1c2giLCJpbXBvcnRfIiwiZGF0YXNldE5hbWUiLCJyZXZlcnNlXyIsIlJlc2VydmVFbmdpbmVlcmluZyIsImNvbm5lY3Rpb24iLCJjb25uT3B0aW9ucyIsIm1vZGVsZXIiLCJkc2xSZXZlcnNlT3V0cHV0UGF0aCIsImdldFZhbGlkYXRvckxpc3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUEsTUFBTUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFFQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxVQUFELENBQXBCOztBQUNBLE1BQU07QUFBRUUsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQSxFQUFMO0FBQVNDLEVBQUFBO0FBQVQsSUFBd0JILElBQTlCOztBQUVBLE1BQU1JLE1BQU0sR0FBR0wsT0FBTyxDQUFDLFVBQUQsQ0FBdEI7O0FBQ0EsTUFBTU0sU0FBUyxHQUFHTixPQUFPLENBQUMsc0JBQUQsQ0FBekI7O0FBQ0EsTUFBTU8sVUFBVSxHQUFHUCxPQUFPLENBQUMsdUJBQUQsQ0FBMUI7O0FBT0MsU0FBU1EsZUFBVCxDQUF5QkMsT0FBekIsRUFBa0NDLFVBQWxDLEVBQThDO0FBQzNDLE1BQUlDLFVBQVUsR0FBR0YsT0FBTyxDQUFDRyxnQkFBUixDQUF5QkYsVUFBekIsQ0FBakI7O0FBRUEsTUFBSSxDQUFDQyxVQUFMLEVBQWlCO0FBQ2IsVUFBTSxJQUFJRSxLQUFKLENBQVcsV0FBVUgsVUFBVyw0REFBaEMsQ0FBTjtBQUNIOztBQUVELE1BQUk7QUFBRUksSUFBQUEsVUFBRjtBQUFjQyxJQUFBQSxnQkFBZDtBQUFnQ0MsSUFBQUE7QUFBaEMsTUFBNENMLFVBQWhEO0FBQ0EsTUFBSSxDQUFFTSxNQUFGLElBQWFILFVBQVUsQ0FBQ0ksS0FBWCxDQUFpQixHQUFqQixDQUFqQjtBQUVBLFNBQU9aLFNBQVMsQ0FBQ0Us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Q0osUUFBUixDQUFpQjNFLE9BQU8sQ0FBQ2dGLG9CQUF6QixDQUFOO0FBQ0gsR0FKRCxDQUlFLE9BQU8zQixLQUFQLEVBQWM7QUFDWixVQUFNQSxLQUFOO0FBQ0gsR0FORCxTQU1VO0FBQ04sVUFBTVgsU0FBUyxDQUFDWSxJQUFWLEVBQU47QUFDSDtBQUNKLENBaEJEOztBQWtCQTFCLE9BQU8sQ0FBQ3FELGdCQUFSLEdBQTJCLE1BQU07QUFDN0IsU0FBT3hCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZNUQsVUFBWixDQUFQO0FBQ0gsQ0FGRCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbmNvbnN0IHsgXywgZnMsIGVhY2hBc3luY18gfSA9IFV0aWw7XG5cbmNvbnN0IExpbmtlciA9IHJlcXVpcmUoJy4vTGlua2VyJyk7XG5jb25zdCBDb25uZWN0b3IgPSByZXF1aXJlKCcuLi9ydW50aW1lL0Nvbm5lY3RvcicpO1xuY29uc3QgVmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvVmFsaWRhdG9ycycpO1xuXG4vKipcbiAqIE9vbG9uZyBEU0wgYXBpXG4gKiBAbW9kdWxlIE9vbG9uZ1xuICovXG5cbiBmdW5jdGlvbiBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSkge1xuICAgIGxldCBkZXBsb3ltZW50ID0gY29udGV4dC5zY2hlbWFEZXBsb3ltZW50W3NjaGVtYU5hbWVdO1xuXG4gICAgaWYgKCFkZXBsb3ltZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiIGhhcyBubyBjb25maWd1cmVkIGRlcGxveW1lbnQgYW5kIGlzIGlnbm9yZWQgaW4gbW9kZWxpbmcuYCk7XG4gICAgfVxuXG4gICAgbGV0IHsgZGF0YVNvdXJjZSwgY29ubmVjdGlvblN0cmluZywgb3B0aW9ucyB9ID0gZGVwbG95bWVudDtcbiAgICBsZXQgWyBkcml2ZXIgXSA9IGRhdGFTb3VyY2Uuc3BsaXQoJy4nKTtcblxuICAgIHJldHVybiBDb25uZWN0b3IuY3JlYXRlQ29ubmVjdG9yKGRyaXZlciwgY29ubmVjdGlvblN0cmluZywgeyBsb2dnZXI6IGNvbnRleHQubG9nZ2VyLCAuLi5vcHRpb25zIH0pOyAgICAgICBcbiB9XG5cbiBhc3luYyBmdW5jdGlvbiBpbXBvcnREYXRhRmlsZXMobWlncmF0b3IsIGZvbGRlck5hbWUpIHtcbiAgICBsZXQgZGF0YVNldFBhdGggPSBwYXRoLmpvaW4obWlncmF0b3IuZGJTY3JpcHRQYXRoLCAnZGF0YScsIGZvbGRlck5hbWUpO1xuICAgIGxldCBkYXRhTGlzdEZpbGUgPSBwYXRoLmpvaW4oZGF0YVNldFBhdGgsICdpbmRleC5saXN0Jyk7XG5cbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGF0YUxpc3RGaWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudHJ5IGZpbGUgb2YgZGF0YXNldCBcIiR7Zm9sZGVyTmFtZX1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMaXN0ID0gZnMucmVhZEZpbGVTeW5jKGRhdGFMaXN0RmlsZSkudG9TdHJpbmcoKS5tYXRjaCgvXi4rJC9nbSk7XG5cbiAgICBpZiAoIWRhdGFMaXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gZWFjaEFzeW5jXyhkYXRhTGlzdCwgYXN5bmMgbGluZSA9PiB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgZGF0YUZpbGUgPSBwYXRoLmpvaW4oZGF0YVNldFBhdGgsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRhdGFGaWxlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSBmaWxlIFwiJHtkYXRhRmlsZX1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IG1pZ3JhdG9yLmxvYWRfKGRhdGFGaWxlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuIH1cblxuLyoqXG4gKiBCdWlsZCBkYXRhYmFzZSBzY3JpcHRzIGFuZCBlbnRpdHkgbW9kZWxzIGZyb20gb29sb25nIGZpbGVzLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyfSBjb250ZXh0LmxvZ2dlciAtIExvZ2dlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LmRzbFNvdXJjZVBhdGhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0Lm1vZGVsT3V0cHV0UGF0aCAgICAgICAgIFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuc2NyaXB0T3V0cHV0UGF0aFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQubWFuaWZlc3RPdXRwdXRQYXRoXG4gKiBAcHJvcGVydHkge2Jvb2x9IGNvbnRleHQudXNlSnNvblNvdXJjZVxuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRleHQuc2NoZW1hRGVwbG95bWVudCAgIFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMuYnVpbGRfID0gYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICBjb250ZXh0LmxvZ2dlci5sb2coJ3ZlcmJvc2UnLCAnU3RhcnQgYnVpbGRpbmcgbW9kZWxzIC4uLicpO1xuXG4gICAgbGV0IGxpbmtlciA9IG5ldyBMaW5rZXIoY29udGV4dCk7XG4gICAgY29udGV4dC5saW5rZXIgPSBsaW5rZXI7ICAgIFxuXG4gICAgbGV0IHNjaGVtYUZpbGVzID0gTGlua2VyLmdldE9vbG9uZ0ZpbGVzKGNvbnRleHQuZHNsU291cmNlUGF0aCwgY29udGV4dC51c2VKc29uU291cmNlKTtcbiAgICBzY2hlbWFGaWxlcy5mb3JFYWNoKHNjaGVtYUZpbGUgPT4gbGlua2VyLmxpbmsoc2NoZW1hRmlsZSkpOyAgXG4gICAgXG4gICAgbGV0IHNjaGVtYVRvQ29ubmVjdG9yID0gXy5tYXBWYWx1ZXMobGlua2VyLnNjaGVtYXMsIChfLCBzY2hlbWFOYW1lKSA9PiB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgICAgIGFzc2VydDogY29ubmVjdG9yO1xuXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XG4gICAgfSk7ICAgIFxuXG4gICAgcmV0dXJuIGVhY2hBc3luY18oY29udGV4dC5zY2hlbWFEZXBsb3ltZW50LCBhc3luYyAoZGVwbG95bWVudFNldHRpbmcsIHNjaGVtYU5hbWUpID0+IHsgICAgICBcbiAgICAgICAgY29udGV4dC5sb2dnZXIubG9nKCd2ZXJib3NlJywgYFByb2Nlc3Npbmcgc2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiIC4uLmApOyAgIFxuICAgICAgICBcbiAgICAgICAgbGV0IHNjaGVtYSA9IGxpbmtlci5zY2hlbWFzW3NjaGVtYU5hbWVdO1xuXG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSBcIiR7c2NoZW1hTmFtZX1cIiBub3QgZm91bmQgaW4gbW9kZWwgc291cmNlLlwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29ubmVjdG9yID0gc2NoZW1hVG9Db25uZWN0b3Jbc2NoZW1hTmFtZV07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBEYk1vZGVsZXIgPSByZXF1aXJlKGAuLi9tb2RlbGVyL2RhdGFiYXNlLyR7Y29ubmVjdG9yLmRyaXZlcn0vTW9kZWxlcmApO1xuICAgICAgICAgICAgbGV0IGRiTW9kZWxlciA9IG5ldyBEYk1vZGVsZXIoY29udGV4dCwgY29ubmVjdG9yLCBkZXBsb3ltZW50U2V0dGluZy5leHRyYU9wdGlvbnMpO1xuICAgICAgICAgICAgbGV0IHJlZmluZWRTY2hlbWEgPSBkYk1vZGVsZXIubW9kZWxpbmcoc2NoZW1hLCBzY2hlbWFUb0Nvbm5lY3Rvcik7XG5cbiAgICAgICAgICAgIGNvbnN0IERhb01vZGVsZXIgPSByZXF1aXJlKCcuLi9tb2RlbGVyL0RhbycpO1xuICAgICAgICAgICAgbGV0IGRhb01vZGVsZXIgPSBuZXcgRGFvTW9kZWxlcihjb250ZXh0LCBjb25uZWN0b3IpO1xuXG4gICAgICAgICAgICBhd2FpdCBkYW9Nb2RlbGVyLm1vZGVsaW5nXyhyZWZpbmVkU2NoZW1hKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICAgICAgfSBcbiAgICB9KTsgICAgICAgICAgICBcbn07XG5cbi8qKlxuICogRGVwbG95IGRhdGFiYXNlIHNjcmlwdHMgaW50byBkYXRhYmFzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gKiBAcHJvcGVydHkge0xvZ2dlcn0gY29udGV4dC5sb2dnZXIgLSBMb2dnZXIgb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5tb2RlbFBhdGhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LmRzbFNvdXJjZVBhdGggXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5zY3JpcHRTb3VyY2VQYXRoIFxuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRleHQuc2NoZW1hRGVwbG95bWVudCAgIFxuICogQHBhcmFtIHtib29sfSByZXNldFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMubWlncmF0ZV8gPSBhc3luYyAoY29udGV4dCwgcmVzZXQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnRleHQubG9nZ2VyLmxvZygndmVyYm9zZScsICdTdGFydCBkZXBsb3lpbmcgbW9kZWxzIC4uLicpO1xuXG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGF3YWl0IGVhY2hBc3luY18oT2JqZWN0LmtleXMoY29udGV4dC5zY2hlbWFEZXBsb3ltZW50KS5yZXZlcnNlKCksIGFzeW5jIChzY2hlbWFOYW1lKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0OiBjb25uZWN0b3I7XG4gICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBNaWdyYXRpb24gPSByZXF1aXJlKGAuLi9taWdyYXRpb24vJHtjb25uZWN0b3IuZHJpdmVyfWApO1xuICAgICAgICAgICAgICAgIGxldCBtaWdyYXRpb24gPSBuZXcgTWlncmF0aW9uKGNvbnRleHQsIHNjaGVtYU5hbWUsIGNvbm5lY3Rvcik7XG4gICAgXG4gICAgICAgICAgICAgICAgYXdhaXQgbWlncmF0aW9uLnJlc2V0XygpOyAgICBcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rvci5lbmRfKCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWFjaEFzeW5jXyhjb250ZXh0LnNjaGVtYURlcGxveW1lbnQsIGFzeW5jIChkZXBsb3ltZW50LCBzY2hlbWFOYW1lKSA9PiB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgICAgIGFzc2VydDogY29ubmVjdG9yO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgTWlncmF0aW9uID0gcmVxdWlyZShgLi4vbWlncmF0aW9uLyR7Y29ubmVjdG9yLmRyaXZlcn1gKTtcbiAgICAgICAgICAgIGxldCBtaWdyYXRpb24gPSBuZXcgTWlncmF0aW9uKGNvbnRleHQsIHNjaGVtYU5hbWUsIGNvbm5lY3Rvcik7XG5cbiAgICAgICAgICAgIGF3YWl0IG1pZ3JhdGlvbi5jcmVhdGVfKGRlcGxveW1lbnQuZXh0cmFPcHRpb25zKTtcblxuICAgICAgICAgICAgYXdhaXQgaW1wb3J0RGF0YUZpbGVzKG1pZ3JhdGlvbiwgJ19pbml0Jyk7ICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rvci5lbmRfKCk7XG4gICAgICAgIH0gXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hTmFtZVxuICovXG5leHBvcnRzLmRhdGFzZXRfID0gYXN5bmMgKGNvbnRleHQsIHNjaGVtYU5hbWUpID0+IHtcbiAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgIGFzc2VydDogY29ubmVjdG9yO1xuICAgIFxuICAgIGxldCBkYXRhU2V0UGF0aCA9IHBhdGguam9pbihjb250ZXh0LnNjcmlwdFNvdXJjZVBhdGgsIGNvbm5lY3Rvci5kcml2ZXIsIGNvbm5lY3Rvci5kYXRhYmFzZSwgJ2RhdGEnKTtcblxuICAgIGlmICghZnMuZXhpc3RzU3luYyhkYXRhU2V0UGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkYXRhU2V0cyA9IGZzLnJlYWRkaXJTeW5jKGRhdGFTZXRQYXRoKTtcbiAgICAgICAgbGV0IHZhbGlkRHMgPSBbXTtcbiAgICAgICAgZGF0YVNldHMuZm9yRWFjaChkcyA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXhGaWxlID0gcGF0aC5qb2luKGRhdGFTZXRQYXRoLCBkcywgJ2luZGV4Lmxpc3QnKTtcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGluZGV4RmlsZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZERzLnB1c2goZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsaWREcztcbiAgICB9XG59XG5cbi8qKlxuICogSW1wb3J0IGEgZGF0YSBzZXQgaW50byBkYXRhYmFzZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyfSBjb250ZXh0LmxvZ2dlciAtIExvZ2dlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LnNjcmlwdFNvdXJjZVBhdGggIFxuICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYU5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0TmFtZVxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMuaW1wb3J0XyA9IGFzeW5jIChjb250ZXh0LCBzY2hlbWFOYW1lLCBkYXRhc2V0TmFtZSkgPT4ge1xuICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgYXNzZXJ0OiBjb25uZWN0b3I7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IE1pZ3JhdGlvbiA9IHJlcXVpcmUoYC4uL21pZ3JhdGlvbi8ke2Nvbm5lY3Rvci5kcml2ZXJ9YCk7XG4gICAgICAgIGxldCBtaWdyYXRpb24gPSBuZXcgTWlncmF0aW9uKGNvbnRleHQsIHNjaGVtYU5hbWUsIGNvbm5lY3Rvcik7XG5cbiAgICAgICAgYXdhaXQgaW1wb3J0RGF0YUZpbGVzKG1pZ3JhdGlvbiwgZGF0YXNldE5hbWUpOyAgICAgICAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGF3YWl0IGNvbm5lY3Rvci5lbmRfKCk7XG4gICAgfSBcbn07XG5cbi8qKlxuICogRXh0cmFjdCBkYXRhYmFzZSBzdHJ1Y3R1cmUgaW50byBvb2xvbmcgZHNsXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHByb3BlcnR5IHtDb25uZWN0b3J9IGNvbnRleHQuY29ubmVjdG9yXG4gKiBAcHJvcGVydHkge0xvZ2dlcn0gY29udGV4dC5sb2dnZXIgXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5kc2xSZXZlcnNlT3V0cHV0UGF0aCBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LmRyaXZlclxuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRleHQuY29ubk9wdGlvbnMgXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0cy5yZXZlcnNlXyA9IGFzeW5jIChjb250ZXh0KSA9PiB7ICAgXG4gICAgbGV0IFJlc2VydmVFbmdpbmVlcmluZyA9IHJlcXVpcmUoYC4uL21vZGVsZXIvZGF0YWJhc2UvJHtjb250ZXh0LmRyaXZlcn0vUmV2ZXJzZUVuZ2luZWVyaW5nYCk7XG4gICAgXG4gICAgbGV0IHsgY29ubmVjdGlvbjogY29ubmVjdGlvblN0cmluZywgLi4ub3B0aW9ucyB9ID0gY29udGV4dC5jb25uT3B0aW9uczsgIFxuICAgIGxldCBjb25uZWN0b3IgPSBDb25uZWN0b3IuY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQuZHJpdmVyLCBjb25uZWN0aW9uU3RyaW5nLCB7IGxvZ2dlcjogY29udGV4dC5sb2dnZXIsIC4uLm9wdGlvbnMgfSk7ICAgICBcbiAgICBhc3NlcnQ6IGNvbm5lY3RvcjsgIFxuXG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG1vZGVsZXIgPSBuZXcgUmVzZXJ2ZUVuZ2luZWVyaW5nKGNvbnRleHQsIGNvbm5lY3Rvcik7XG5cbiAgICAgICAgYXdhaXQgbW9kZWxlci5yZXZlcnNlXyhjb250ZXh0LmRzbFJldmVyc2VPdXRwdXRQYXRoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgIH0gXG59O1xuXG5leHBvcnRzLmdldFZhbGlkYXRvckxpc3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKFZhbGlkYXRvcnMpOyAgICBcbn0iXX0=