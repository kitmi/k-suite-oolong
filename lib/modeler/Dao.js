"use strict";

require("source-map-support/register");

const path = require('path');

const {
  _,
  fs,
  pascalCase,
  replaceAll
} = require('rk-utils');

const swig = require('swig-templates');

const OolTypes = require('../lang/OolTypes');

const OolUtil = require('../lang/OolUtils');

const JsLang = require('./util/ast.js');

const OolToAst = require('./util/oolToAst.js');

const Snippets = require('./dao/snippets');

const ChainableType = [OolToAst.AST_BLK_VALIDATOR_CALL, OolToAst.AST_BLK_PROCESSOR_CALL, OolToAst.AST_BLK_ACTIVATOR_CALL];

const getFieldName = t => t.split('.').pop();

const isChainable = (current, next) => ChainableType.indexOf(current.type) > -1 && current.target === next.target && next.type === current.type;

const chainCall = (lastBlock, lastType, currentBlock, currentType) => {
  if (lastBlock) {
    if (lastType === 'ValidatorCall') {
      if (!(currentType === 'ValidatorCall')) {
        throw new Error('Unexpected currentType');
      }

      currentBlock = JsLang.astBinExp(lastBlock, '&&', currentBlock);
    } else {
      if (!(currentType === 'ModifierCall')) {
        throw new Error('Unexpected currentType');
      }

      currentBlock.arguments[0] = lastBlock;
    }
  }

  return currentBlock;
};

const asyncMethodNaming = name => name + '_';

const indentLines = (lines, indentation) => lines.split('\n').map((line, i) => i === 0 ? line : _.repeat(' ', indentation) + line).join('\n');

const OOL_MODIFIER_RETURN = {
  [OolTypes.Modifier.VALIDATOR]: () => [JsLang.astReturn(true)],
  [OolTypes.Modifier.PROCESSOR]: args => [JsLang.astReturn(JsLang.astId(args[0]))],
  [OolTypes.Modifier.ACTIVATOR]: () => [JsLang.astReturn(JsLang.astId("undefined"))]
};

class DaoModeler {
  constructor(context, connector) {
    this.logger = context.logger;
    this.outputPath = context.modelOutputPath;
    this.connector = connector;
  }

  modeling_(schema) {
    this.logger.log('info', 'Generating entity models for schema "' + schema.name + '"...');

    this._generateSchemaModel(schema);

    this._generateEntityModel(schema);
  }

  _generateSchemaModel(schema) {
    let capitalized = pascalCase(schema.name);
    let locals = {
      driver: this.connector.driver,
      className: capitalized,
      schemaName: schema.name
    };
    let classTemplate = path.resolve(__dirname, 'database', this.connector.driver, 'Database.js.swig');
    let classCode = swig.renderFile(classTemplate, locals);
    let modelFilePath = path.resolve(this.outputPath, capitalized + '.js');
    fs.ensureFileSync(modelFilePath);
    fs.writeFileSync(modelFilePath, classCode);
    this.logger.log('info', 'Generated database model: ' + modelFilePath);
  }

  _generateEntityModel(schema) {
    _.forOwn(schema.entities, (entity, entityInstanceName) => {
      let capitalized = pascalCase(entityInstanceName);
      let sharedContext = {
        mapOfFunctorToFile: {},
        newFunctorFiles: []
      };

      let {
        ast: astClassMain,
        fieldReferences
      } = this._processFieldModifiers(entity, sharedContext);

      astClassMain = [astClassMain];
      let uniqueKeys = [_.castArray(entity.key)];

      if (entity.indexes) {
        entity.indexes.forEach(index => {
          if (index.unique) {
            uniqueKeys.push(index.fields);
          }
        });
      }

      let modelMeta = {
        schemaName: schema.name,
        name: entityInstanceName,
        keyField: entity.key,
        fields: _.mapValues(entity.fields, f => f.toJSON()),
        indexes: entity.indexes || [],
        features: entity.features || [],
        uniqueKeys,
        fieldDependencies: fieldReferences
      };

      if (entity.interfaces) {
        let astInterfaces = this._buildInterfaces(entity, modelMeta, sharedContext);

        astClassMain = astClassMain.concat(astInterfaces);
      }

      let importLines = [];

      if (!_.isEmpty(sharedContext.mapOfFunctorToFile)) {
        _.forOwn(sharedContext.mapOfFunctorToFile, (fileName, functionName) => {
          importLines.push(JsLang.astToCode(JsLang.astRequire(functionName, fileName)));
        });
      }

      if (!_.isEmpty(sharedContext.newFunctorFiles)) {
        _.each(sharedContext.newFunctorFiles, entry => {
          this._generateFunctionTemplateFile(schema, entry);
        });
      }

      let locals = {
        imports: importLines.join('\n'),
        className: capitalized,
        entityMeta: JSON.stringify(modelMeta, null, 4),
        classBody: indentLines(astClassMain.map(block => JsLang.astToCode(block)).join('\n\n'), 8)
      };
      let classTemplate = path.resolve(__dirname, 'database', this.connector.driver, 'EntityModel.js.swig');
      let classCode = swig.renderFile(classTemplate, locals);
      let modelFilePath = path.resolve(this.outputPath, schema.name, capitalized + '.js');
      fs.ensureFileSync(modelFilePath);
      fs.writeFileSync(modelFilePath, classCode);
      this.logger.log('info', 'Generated entity model: ' + modelFilePath);
    });
  }

  _processFieldModifiers(entity, sharedContext) {
    let compileContext = OolToAst.createCompileContext(entity.name, this.logger, sharedContext);
    const allFinished = OolToAst.createTopoId(compileContext, 'done.');
    let fieldReferences = {};

    _.forOwn(entity.fields, (field, fieldName) => {
      let topoId = OolToAst.compileField(fieldName, field, compileContext);
      OolToAst.dependsOn(compileContext, topoId, allFinished);
    });

    let deps = compileContext.topoSort.sort();
    deps = deps.filter(dep => compileContext.mapOfTokenToMeta.has(dep));
    let methodBodyValidateAndFill = [],
        lastFieldsGroup,
        methodBodyCache = [],
        lastBlock,
        lastAstType;

    const _mergeDoValidateAndFillCode = function (fieldName, references, astCache, requireTargetField) {
      let fields = (requireTargetField ? [fieldName] : []).concat(references);
      let checker = fields.join(',');

      if (lastFieldsGroup && lastFieldsGroup.checker !== checker) {
        methodBodyValidateAndFill = methodBodyValidateAndFill.concat(Snippets._fieldRequirementCheck(lastFieldsGroup.fieldName, lastFieldsGroup.references, methodBodyCache, lastFieldsGroup.requireTargetField));
        methodBodyCache = [];
      }

      methodBodyCache = methodBodyCache.concat(astCache);
      lastFieldsGroup = {
        fieldName,
        references,
        requireTargetField,
        checker
      };
    };

    _.each(deps, (dep, i) => {
      let sourceMap = compileContext.mapOfTokenToMeta.get(dep);
      let astBlock = compileContext.astMap[dep];
      let targetFieldName = getFieldName(sourceMap.target);

      if (sourceMap.references) {
        let fieldReference = fieldReferences[targetFieldName];

        if (!fieldReference) {
          fieldReferences[targetFieldName] = fieldReference = [];
        }

        sourceMap.references.forEach(ref => {
          if (fieldReference.indexOf(ref) === -1) fieldReference.push(ref);
        });
      }

      if (lastBlock) {
        astBlock = chainCall(lastBlock, lastAstType, astBlock, sourceMap.type);
        lastBlock = undefined;
      }

      if (i < deps.length - 1) {
        let nextType = compileContext.mapOfTokenToMeta.get(deps[i + 1]);

        if (isChainable(sourceMap, nextType)) {
          lastBlock = astBlock;
          lastAstType = sourceMap.type;
          return;
        }
      }

      if (sourceMap.type === OolToAst.AST_BLK_VALIDATOR_CALL) {
        let astCache = Snippets._validateCheck(targetFieldName, astBlock);

        _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, true);
      } else if (sourceMap.type === OolToAst.AST_BLK_PROCESSOR_CALL) {
        let astCache = JsLang.astAssign(JsLang.astVarRef(sourceMap.target, true), astBlock, `Processing "${targetFieldName}"`);

        _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, true);
      } else if (sourceMap.type === OolToAst.AST_BLK_ACTIVATOR_CALL) {
        let astCache = JsLang.astAssign(JsLang.astVarRef(sourceMap.target, true), astBlock, `Activating "${targetFieldName}"`);

        _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, false);
      } else {
        throw new Error('To be implemented.');
      }
    });

    if (!_.isEmpty(methodBodyCache)) {
      methodBodyValidateAndFill = methodBodyValidateAndFill.concat(Snippets._fieldRequirementCheck(lastFieldsGroup.fieldName, lastFieldsGroup.references, methodBodyCache, lastFieldsGroup.requireTargetField));
    }

    return {
      ast: JsLang.astMemberMethod(asyncMethodNaming('applyModifiers'), ['context', 'isUpdating'], Snippets._applyModifiersHeader.concat(methodBodyValidateAndFill).concat([JsLang.astReturn(JsLang.astId('context'))]), false, true, true, 'Applying predefined modifiers to entity fields.'),
      fieldReferences
    };
  }

  _generateFunctionTemplateFile(schema, {
    functionName,
    functorType,
    fileName,
    args
  }) {
    let filePath = path.resolve(this.outputPath, schema.name, fileName);

    if (fs.existsSync(filePath)) {
      this.logger.log('info', `${_.upperFirst(functorType)} "${fileName}" exists. File generating skipped.`);
      return;
    }

    let ast = JsLang.astProgram();
    JsLang.astPushInBody(ast, JsLang.astFunction(functionName, args, OOL_MODIFIER_RETURN[functorType](args)));
    JsLang.astPushInBody(ast, JsLang.astAssign('module.exports', JsLang.astVarRef(functionName)));
    fs.ensureFileSync(filePath);
    fs.writeFileSync(filePath, JsLang.astToCode(ast));
    this.logger.log('info', `Generated ${functorType} file: ${filePath}`);
  }

  _buildInterfaces(entity, modelMetaInit, sharedContext) {
    let ast = [];

    _.forOwn(entity.interfaces, (method, name) => {
      this.logger.info('Building interface: ' + name);
      let astBody = [JsLang.astVarDeclare('$meta', JsLang.astVarRef('this.meta.interfaces.' + name), true, false, 'Retrieving the meta data')];
      let compileContext = OolToAst.createCompileContext(entity.name, this.logger, sharedContext);

      _.each(method.implementation, operation => {
        compileContext.modelVars.add(operation.model);
      });

      let paramMeta;

      if (method.accept) {
        paramMeta = this._processParams(method.accept, compileContext);
      }

      modelMetaInit['interfaces'] || (modelMetaInit['interfaces'] = {});
      modelMetaInit['interfaces'][name] = {
        params: Object.values(paramMeta)
      };

      _.each(method.implementation, (operation, index) => {
        OolToAst.compileDbOperation(index, operation, compileContext, compileContext.mainStartId);
      });

      if (method.return) {
        OolToAst.compileExceptionalReturn(method.return, compileContext);
      }

      let deps = compileContext.topoSort.sort();
      this.logger.verbose('All dependencies:\n' + JSON.stringify(deps, null, 2));
      deps = deps.filter(dep => compileContext.mapOfTokenToMeta.has(dep));
      this.logger.verbose('All necessary source code:\n' + JSON.stringify(deps, null, 2));

      _.each(deps, dep => {
        let sourceMap = compileContext.mapOfTokenToMeta.get(dep);
        let astBlock = compileContext.astMap[dep];
        this.logger.verbose('Code point "' + dep + '":\n' + JSON.stringify(sourceMap, null, 2));
        let targetFieldName = sourceMap.target;

        if (sourceMap.type === OolToAst.AST_BLK_VALIDATOR_CALL) {
          astBlock = Snippets._validateCheck(targetFieldName, astBlock);
        } else if (sourceMap.type === OolToAst.AST_BLK_PROCESSOR_CALL) {
          astBlock = JsLang.astAssign(JsLang.astVarRef(sourceMap.target, true), astBlock, `Processing "${targetFieldName}"`);
        } else if (sourceMap.type === OolToAst.AST_BLK_ACTIVATOR_CALL) {
          astBlock = JsLang.astAssign(JsLang.astVarRef(sourceMap.target, true), astBlock, `Activating "${targetFieldName}"`);
        }

        astBody = astBody.concat(_.castArray(astBlock));
      });

      ast.push(JsLang.astMemberMethod(asyncMethodNaming(name), Object.keys(paramMeta), astBody, false, true, true, replaceAll(_.kebabCase(name), '-', ' ')));
    });

    return ast;
  }

  _processParams(acceptParams, compileContext) {
    let paramMeta = {};
    acceptParams.forEach((param, i) => {
      OolToAst.compileParam(i, param, compileContext);
      paramMeta[param.name] = param;
    });
    return paramMeta;
  }

}

module.exports = DaoModeler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbGVyL0Rhby5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIl8iLCJmcyIsInBhc2NhbENhc2UiLCJyZXBsYWNlQWxsIiwic3dpZyIsIk9vbFR5cGVzIiwiT29sVXRpbCIsIkpzTGFuZyIsIk9vbFRvQXN0IiwiU25pcHBldHMiLCJDaGFpbmFibGVUeXBlIiwiQVNUX0JMS19WQUxJREFUT1JfQ0FMTCIsIkFTVF9CTEtfUFJPQ0VTU09SX0NBTEwiLCJBU1RfQkxLX0FDVElWQVRPUl9DQUxMIiwiZ2V0RmllbGROYW1lIiwidCIsInNwbGl0IiwicG9wIiwiaXNDaGFpbmFibGUiLCJjdXJyZW50IiwibmV4dCIsImluZGV4T2YiLCJ0eXBlIiwidGFyZ2V0IiwiY2hhaW5DYWxsIiwibGFzdEJsb2NrIiwibGFzdFR5cGUiLCJjdXJyZW50QmxvY2siLCJjdXJyZW50VHlwZSIsImFzdEJpbkV4cCIsImFyZ3VtZW50cyIsImFzeW5jTWV0aG9kTmFtaW5nIiwibmFtZSIsImluZGVudExpbmVzIiwibGluZXMiLCJpbmRlbnRhdGlvbiIsIm1hcCIsImxpbmUiLCJpIiwicmVwZWF0Iiwiam9pbiIsIk9PTF9NT0RJRklFUl9SRVRVUk4iLCJNb2RpZmllciIsIlZBTElEQVRPUiIsImFzdFJldHVybiIsIlBST0NFU1NPUiIsImFyZ3MiLCJhc3RJZCIsIkFDVElWQVRPUiIsIkRhb01vZGVsZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJjb25uZWN0b3IiLCJsb2dnZXIiLCJvdXRwdXRQYXRoIiwibW9kZWxPdXRwdXRQYXRoIiwibW9kZWxpbmdfIiwic2NoZW1hIiwibG9nIiwiX2dlbmVyYXRlU2NoZW1hTW9kZWwiLCJfZ2VuZXJhdGVFbnRpdHlNb2RlbCIsImNhcGl0YWxpemVkIiwibG9jYWxzIiwiZHJpdmVyIiwiY2xhc3NOYW1lIiwic2NoZW1hTmFtZSIsImNsYXNzVGVtcGxhdGUiLCJyZXNvbHZlIiwiX19kaXJuYW1lIiwiY2xhc3NDb2RlIiwicmVuZGVyRmlsZSIsIm1vZGVsRmlsZVBhdGgiLCJlbnN1cmVGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJmb3JPd24iLCJlbnRpdGllcyIsImVudGl0eSIsImVudGl0eUluc3RhbmNlTmFtZSIsInNoYXJlZENvbnRleHQiLCJtYXBPZkZ1bmN0b3JUb0ZpbGUiLCJuZXdGdW5jdG9yRmlsZXMiLCJhc3QiLCJhc3RDbGFzc01haW4iLCJmaWVsZFJlZmVyZW5jZXMiLCJfcHJvY2Vzc0ZpZWxkTW9kaWZpZXJzIiwidW5pcXVlS2V5cyIsImNhc3RBcnJheSIsImtleSIsImluZGV4ZXMiLCJmb3JFYWNoIiwiaW5kZXgiLCJ1bmlxdWUiLCJwdXNoIiwiZmllbGRzIiwibW9kZWxNZXRhIiwia2V5RmllbGQiLCJtYXBWYWx1ZXMiLCJmIiwidG9KU09OIiwiZmVhdHVyZXMiLCJmaWVsZERlcGVuZGVuY2llcyIsImludGVyZmFjZXMiLCJhc3RJbnRlcmZhY2VzIiwiX2J1aWxkSW50ZXJmYWNlcyIsImNvbmNhdCIsImltcG9ydExpbmVzIiwiaXNFbXB0eSIsImZpbGVOYW1lIiwiZnVuY3Rpb25OYW1lIiwiYXN0VG9Db2RlIiwiYXN0UmVxdWlyZSIsImVhY2giLCJlbnRyeSIsIl9nZW5lcmF0ZUZ1bmN0aW9uVGVtcGxhdGVGaWxlIiwiaW1wb3J0cyIsImVudGl0eU1ldGEiLCJKU09OIiwic3RyaW5naWZ5IiwiY2xhc3NCb2R5IiwiYmxvY2siLCJjb21waWxlQ29udGV4dCIsImNyZWF0ZUNvbXBpbGVDb250ZXh0IiwiYWxsRmluaXNoZWQiLCJjcmVhdGVUb3BvSWQiLCJmaWVsZCIsImZpZWxkTmFtZSIsInRvcG9JZCIsImNvbXBpbGVGaWVsZCIsImRlcGVuZHNPbiIsImRlcHMiLCJ0b3BvU29ydCIsInNvcnQiLCJmaWx0ZXIiLCJkZXAiLCJtYXBPZlRva2VuVG9NZXRhIiwiaGFzIiwibWV0aG9kQm9keVZhbGlkYXRlQW5kRmlsbCIsImxhc3RGaWVsZHNHcm91cCIsIm1ldGhvZEJvZHlDYWNoZSIsImxhc3RBc3RUeXBlIiwiX21lcmdlRG9WYWxpZGF0ZUFuZEZpbGxDb2RlIiwicmVmZXJlbmNlcyIsImFzdENhY2hlIiwicmVxdWlyZVRhcmdldEZpZWxkIiwiY2hlY2tlciIsIl9maWVsZFJlcXVpcmVtZW50Q2hlY2siLCJzb3VyY2VNYXAiLCJnZXQiLCJhc3RCbG9jayIsImFzdE1hcCIsInRhcmdldEZpZWxkTmFtZSIsImZpZWxkUmVmZXJlbmNlIiwicmVmIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwibmV4dFR5cGUiLCJfdmFsaWRhdGVDaGVjayIsImFzdEFzc2lnbiIsImFzdFZhclJlZiIsIkVycm9yIiwiYXN0TWVtYmVyTWV0aG9kIiwiX2FwcGx5TW9kaWZpZXJzSGVhZGVyIiwiZnVuY3RvclR5cGUiLCJmaWxlUGF0aCIsImV4aXN0c1N5bmMiLCJ1cHBlckZpcnN0IiwiYXN0UHJvZ3JhbSIsImFzdFB1c2hJbkJvZHkiLCJhc3RGdW5jdGlvbiIsIm1vZGVsTWV0YUluaXQiLCJtZXRob2QiLCJpbmZvIiwiYXN0Qm9keSIsImFzdFZhckRlY2xhcmUiLCJpbXBsZW1lbnRhdGlvbiIsIm9wZXJhdGlvbiIsIm1vZGVsVmFycyIsImFkZCIsIm1vZGVsIiwicGFyYW1NZXRhIiwiYWNjZXB0IiwiX3Byb2Nlc3NQYXJhbXMiLCJwYXJhbXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJjb21waWxlRGJPcGVyYXRpb24iLCJtYWluU3RhcnRJZCIsInJldHVybiIsImNvbXBpbGVFeGNlcHRpb25hbFJldHVybiIsInZlcmJvc2UiLCJrZXlzIiwia2ViYWJDYXNlIiwiYWNjZXB0UGFyYW1zIiwicGFyYW0iLCJjb21waWxlUGFyYW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUVBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQSxDQUFGO0FBQUtDLEVBQUFBLEVBQUw7QUFBU0MsRUFBQUEsVUFBVDtBQUFxQkMsRUFBQUE7QUFBckIsSUFBcUNKLE9B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cUIsQ0FBQ3dHLEtBQUQsRUFBUTNKLENBQVIsS0FBYztBQUMvQjlCLE1BQUFBLFFBQVEsQ0FBQzBMLFlBQVQsQ0FBc0I1SixDQUF0QixFQUF5QjJKLEtBQXpCLEVBQWdDekUsY0FBaEM7QUFDQTJELE1BQUFBLFNBQVMsQ0FBQ2MsS0FBSyxDQUFDakssSUFBUCxDQUFULEdBQXdCaUssS0FBeEI7QUFDSCxLQUhEO0FBS0EsV0FBT2QsU0FBUDtBQUNIOztBQTFjWTs7QUE2Y2pCZ0IsTUFBTSxDQUFDQyxPQUFQLEdBQWlCbkosVUFBakIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHsgXywgZnMsIHBhc2NhbENhc2UsIHJlcGxhY2VBbGwgfSAgPSByZXF1aXJlKCdyay11dGlscycpO1xuY29uc3Qgc3dpZyAgPSByZXF1aXJlKCdzd2lnLXRlbXBsYXRlcycpO1xuXG5jb25zdCBPb2xUeXBlcyA9IHJlcXVpcmUoJy4uL2xhbmcvT29sVHlwZXMnKTtcbmNvbnN0IE9vbFV0aWwgPSByZXF1aXJlKCcuLi9sYW5nL09vbFV0aWxzJyk7XG5jb25zdCBKc0xhbmcgPSByZXF1aXJlKCcuL3V0aWwvYXN0LmpzJyk7XG5jb25zdCBPb2xUb0FzdCA9IHJlcXVpcmUoJy4vdXRpbC9vb2xUb0FzdC5qcycpO1xuY29uc3QgU25pcHBldHMgPSByZXF1aXJlKCcuL2Rhby9zbmlwcGV0cycpO1xuXG5jb25zdCBDaGFpbmFibGVUeXBlID0gW1xuICAgIE9vbFRvQXN0LkFTVF9CTEtfVkFMSURBVE9SX0NBTEwsIFxuICAgIE9vbFRvQXN0LkFTVF9CTEtfUFJPQ0VTU09SX0NBTEwsXG4gICAgT29sVG9Bc3QuQVNUX0JMS19BQ1RJVkFUT1JfQ0FMTFxuXTtcblxuY29uc3QgZ2V0RmllbGROYW1lID0gdCA9PiB0LnNwbGl0KCcuJykucG9wKCk7XG5jb25zdCBpc0NoYWluYWJsZSA9IChjdXJyZW50LCBuZXh0KSA9PiBDaGFpbmFibGVUeXBlLmluZGV4T2YoY3VycmVudC50eXBlKSA+IC0xXG4gICAgJiYgY3VycmVudC50YXJnZXQgPT09IG5leHQudGFyZ2V0XG4gICAgJiYgbmV4dC50eXBlID09PSBjdXJyZW50LnR5cGU7XG5jb25zdCBjaGFpbkNhbGwgPSAobGFzdEJsb2NrLCBsYXN0VHlwZSwgY3VycmVudEJsb2NrLCBjdXJyZW50VHlwZSkgPT4ge1xuICAgIGlmIChsYXN0QmxvY2spIHtcbiAgICAgICAgaWYgKGxhc3RUeXBlID09PSAnVmFsaWRhdG9yQ2FsbCcpIHtcbiAgICAgICAgICAgIGFzc2VydDogY3VycmVudFR5cGUgPT09ICdWYWxpZGF0b3JDYWxsJywgJ1VuZXhwZWN0ZWQgY3VycmVudFR5cGUnO1xuXG4gICAgICAgICAgICBjdXJyZW50QmxvY2sgPSBKc0xhbmcuYXN0QmluRXhwKGxhc3RCbG9jaywgJyYmJywgY3VycmVudEJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydDogY3VycmVudFR5cGUgPT09ICdNb2RpZmllckNhbGwnLCAnVW5leHBlY3RlZCBjdXJyZW50VHlwZSc7XG5cbiAgICAgICAgICAgIGN1cnJlbnRCbG9jay5hcmd1bWVudHNbMF0gPSBsYXN0QmxvY2s7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudEJsb2NrO1xufTtcbmNvbnN0IGFzeW5jTWV0aG9kTmFtaW5nID0gKG5hbWUpID0+IG5hbWUgKyAnXyc7XG5cbmNvbnN0IGluZGVudExpbmVzID0gKGxpbmVzLCBpbmRlbnRhdGlvbikgPT4gbGluZXMuc3BsaXQoJ1xcbicpLm1hcCgobGluZSwgaSkgPT4gaSA9PT0gMCA/IGxpbmUgOiAoXy5yZXBlYXQoJyAnLCBpbmRlbnRhdGlvbikgKyBsaW5lKSkuam9pbignXFxuJyk7XG5cbmNvbnN0IE9PTF9NT0RJRklFUl9SRVRVUk4gPSB7XG4gICAgW09vbFR5cGVzLk1vZGlmaWVyLlZBTElEQVRPUl06ICgpID0+IFsgSnNMYW5nLmFzdFJldHVybih0cnVlKSBdLFxuICAgIFtPb2xUeXBlcy5Nb2RpZmllci5QUk9DRVNTT1JdOiBhcmdzID0+IFsgSnNMYW5nLmFzdFJldHVybihKc0xhbmcuYXN0SWQoYXJnc1swXSkpIF0sXG4gICAgW09vbFR5cGVzLk1vZGlmaWVyLkFDVElWQVRPUl06ICgpID0+IFsgSnNMYW5nLmFzdFJldHVybihKc0xhbmcuYXN0SWQoXCJ1bmRlZmluZWRcIikpIF1cbn07XG5cbi8qKlxuICogT29sb25nIGRhdGFiYXNlIGFjY2VzcyBvYmplY3QgKERBTykgbW9kZWxlci5cbiAqIEBjbGFzc1xuICovXG5jbGFzcyBEYW9Nb2RlbGVyIHtcbiAgICAvKiogICAgIFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAgICogQHByb3BlcnR5IHtMb2dnZXJ9IGNvbnRleHQubG9nZ2VyIC0gTG9nZ2VyIG9iamVjdCAgICAgICAgICBcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gY29udGV4dC5tb2RlbE91dHB1dFBhdGggLSBHZW5lcmF0ZWQgbW9kZWwgb3V0cHV0IHBhdGhcbiAgICAgKiBAcGFyYW0ge0Nvbm5lY3Rvcn0gY29ubmVjdG9yICAgICAgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY29ubmVjdG9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gY29udGV4dC5sb2dnZXI7ICAgICAgIFxuICAgICAgICB0aGlzLm91dHB1dFBhdGggPSBjb250ZXh0Lm1vZGVsT3V0cHV0UGF0aDtcblxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjsgICAgICAgIFxuICAgIH1cblxuICAgIG1vZGVsaW5nXyhzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdpbmZvJywgJ0dlbmVyYXRpbmcgZW50aXR5IG1vZGVscyBmb3Igc2NoZW1hIFwiJyArIHNjaGVtYS5uYW1lICsgJ1wiLi4uJyk7XG5cbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVTY2hlbWFNb2RlbChzY2hlbWEpO1xuICAgICAgICB0aGlzLl9nZW5lcmF0ZUVudGl0eU1vZGVsKHNjaGVtYSk7XG4gICAgICAgIC8vdGhpcy5fZ2VuZXJhdGVWaWV3TW9kZWwoKTtcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGVTY2hlbWFNb2RlbChzY2hlbWEpIHtcbiAgICAgICAgbGV0IGNhcGl0YWxpemVkID0gcGFzY2FsQ2FzZShzY2hlbWEubmFtZSk7XG5cbiAgICAgICAgbGV0IGxvY2FscyA9IHtcbiAgICAgICAgICAgIGRyaXZlcjogdGhpcy5jb25uZWN0b3IuZHJpdmVyLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjYXBpdGFsaXplZCxcbiAgICAgICAgICAgIHNjaGVtYU5hbWU6IHNjaGVtYS5uYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGNsYXNzVGVtcGxhdGUgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnZGF0YWJhc2UnLCB0aGlzLmNvbm5lY3Rvci5kcml2ZXIsICdEYXRhYmFzZS5qcy5zd2lnJyk7XG4gICAgICAgIGxldCBjbGFzc0NvZGUgPSBzd2lnLnJlbmRlckZpbGUoY2xhc3NUZW1wbGF0ZSwgbG9jYWxzKTtcblxuICAgICAgICBsZXQgbW9kZWxGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm91dHB1dFBhdGgsIGNhcGl0YWxpemVkICsgJy5qcycpO1xuICAgICAgICBmcy5lbnN1cmVGaWxlU3luYyhtb2RlbEZpbGVQYXRoKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhtb2RlbEZpbGVQYXRoLCBjbGFzc0NvZGUpO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnaW5mbycsICdHZW5lcmF0ZWQgZGF0YWJhc2UgbW9kZWw6ICcgKyBtb2RlbEZpbGVQYXRoKTtcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGVFbnRpdHlNb2RlbChzY2hlbWEpIHtcbiAgICAgICAgXy5mb3JPd24oc2NoZW1hLmVudGl0aWVzLCAoZW50aXR5LCBlbnRpdHlJbnN0YW5jZU5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCBjYXBpdGFsaXplZCA9IHBhc2NhbENhc2UoZW50aXR5SW5zdGFuY2VOYW1lKTsgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgLy9zaGFyZWQgaW5mb3JtYXRpb24gd2l0aCBtb2RlbCBDUlVEIGFuZCBjdXN0b21pemVkIGludGVyZmFjZXNcbiAgICAgICAgICAgIGxldCBzaGFyZWRDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG1hcE9mRnVuY3RvclRvRmlsZToge30sXG4gICAgICAgICAgICAgICAgbmV3RnVuY3RvckZpbGVzOiBbXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbGV0IHsgYXN0OiBhc3RDbGFzc01haW4sIGZpZWxkUmVmZXJlbmNlcyB9ID0gdGhpcy5fcHJvY2Vzc0ZpZWxkTW9kaWZpZXJzKGVudGl0eSwgc2hhcmVkQ29udGV4dCk7XG4gICAgICAgICAgICBhc3RDbGFzc01haW4gPSBbIGFzdENsYXNzTWFpbiBdO1xuXG4gICAgICAgICAgICAvL3ByZXBhcmUgbWV0YSBkYXRhXG4gICAgICAgICAgICBsZXQgdW5pcXVlS2V5cyA9IFsgXy5jYXN0QXJyYXkoZW50aXR5LmtleSkgXTtcblxuICAgICAgICAgICAgaWYgKGVudGl0eS5pbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5LmluZGV4ZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleC51bmlxdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUtleXMucHVzaChpbmRleC5maWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtb2RlbE1ldGEgPSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hTmFtZTogc2NoZW1hLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogZW50aXR5SW5zdGFuY2VOYW1lLFxuICAgICAgICAgICAgICAgIGtleUZpZWxkOiBlbnRpdHkua2V5LFxuICAgICAgICAgICAgICAgIGZpZWxkczogXy5tYXBWYWx1ZXMoZW50aXR5LmZpZWxkcywgZiA9PiBmLnRvSlNPTigpKSxcbiAgICAgICAgICAgICAgICBpbmRleGVzOiBlbnRpdHkuaW5kZXhlcyB8fCBbXSxcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogZW50aXR5LmZlYXR1cmVzIHx8IFtdLFxuICAgICAgICAgICAgICAgIHVuaXF1ZUtleXMsXG4gICAgICAgICAgICAgICAgZmllbGREZXBlbmRlbmNpZXM6IGZpZWxkUmVmZXJlbmNlc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy9idWlsZCBjdXN0b21pemVkIGludGVyZmFjZXMgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChlbnRpdHkuaW50ZXJmYWNlcykge1xuICAgICAgICAgICAgICAgIGxldCBhc3RJbnRlcmZhY2VzID0gdGhpcy5fYnVpbGRJbnRlcmZhY2VzKGVudGl0eSwgbW9kZWxNZXRhLCBzaGFyZWRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFzdEludGVyZmFjZXMpO1xuICAgICAgICAgICAgICAgIC8vbGV0IGFzdENsYXNzID0gYXN0Q2xhc3NNYWluW2FzdENsYXNzTWFpbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAvL0pzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdENsYXNzLCBhc3RJbnRlcmZhY2VzKTtcbiAgICAgICAgICAgICAgICBhc3RDbGFzc01haW4gPSBhc3RDbGFzc01haW4uY29uY2F0KGFzdEludGVyZmFjZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaW1wb3J0TGluZXMgPSBbXTtcblxuICAgICAgICAgICAgLy9nZW5lcmF0ZSBmdW5jdG9ycyBpZiBhbnlcbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5KHNoYXJlZENvbnRleHQubWFwT2ZGdW5jdG9yVG9GaWxlKSkge1xuICAgICAgICAgICAgICAgIF8uZm9yT3duKHNoYXJlZENvbnRleHQubWFwT2ZGdW5jdG9yVG9GaWxlLCAoZmlsZU5hbWUsIGZ1bmN0aW9uTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRMaW5lcy5wdXNoKEpzTGFuZy5hc3RUb0NvZGUoSnNMYW5nLmFzdFJlcXVpcmUoZnVuY3Rpb25OYW1lLCBmaWxlTmFtZSkpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShzaGFyZWRDb250ZXh0Lm5ld0Z1bmN0b3JGaWxlcykpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goc2hhcmVkQ29udGV4dC5uZXdGdW5jdG9yRmlsZXMsIGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVGdW5jdGlvblRlbXBsYXRlRmlsZShzY2hlbWEsIGVudHJ5KTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Fzc2VtYmxlIHRoZSBzb3VyY2UgY29kZSBmaWxlXG4gICAgICAgICAgICAvL0pzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdCwgYXN0Q2xhc3NNYWluKTtcblxuICAgICAgICAgICAgLy9Kc0xhbmcuYXN0UHVzaEluQm9keShhc3QsIGVudGl0eS5maWVsZHMubWFwKCh2LCBrKSA9PiBKc0xhbmcuYXN0QXNzaWduKGNhcGl0YWxpemVkICsgJy5GXycgKyBfLnNuYWtlQ2FzZShrKS50b1VwcGVyQ2FzZSgpLCBrKSkpOyAgIFxuXG4gICAgICAgICAgICBsZXQgbG9jYWxzID0ge1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IGltcG9ydExpbmVzLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2FwaXRhbGl6ZWQsXG4gICAgICAgICAgICAgICAgZW50aXR5TWV0YTogSlNPTi5zdHJpbmdpZnkobW9kZWxNZXRhLCBudWxsLCA0KSxcbiAgICAgICAgICAgICAgICBjbGFzc0JvZHk6IGluZGVudExpbmVzKGFzdENsYXNzTWFpbi5tYXAoYmxvY2sgPT4gSnNMYW5nLmFzdFRvQ29kZShibG9jaykpLmpvaW4oJ1xcblxcbicpLCA4KSxcbiAgICAgICAgICAgICAgICAvL2Z1bmN0b3JzOiBcbiAgICAgICAgICAgICAgICAvKiBfLnJlZHVjZShzaGFyZWRDb250ZXh0Lm5ld0Z1bmN0b3JGaWxlcywgKHJlc3VsdCwgZnVuY3RvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJyQnICsgZnVuY3Rvci5mdW5jdGlvbk5hbWVdID0gZnVuY3Rvci5mdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSwge30pICovXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgY2xhc3NUZW1wbGF0ZSA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICdkYXRhYmFzZScsIHRoaXMuY29ubmVjdG9yLmRyaXZlciwgJ0VudGl0eU1vZGVsLmpzLnN3aWcnKTtcbiAgICAgICAgICAgIGxldCBjbGFzc0NvZGUgPSBzd2lnLnJlbmRlckZpbGUoY2xhc3NUZW1wbGF0ZSwgbG9jYWxzKTtcblxuICAgICAgICAgICAgbGV0IG1vZGVsRmlsZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5vdXRwdXRQYXRoLCBzY2hlbWEubmFtZSwgY2FwaXRhbGl6ZWQgKyAnLmpzJyk7XG4gICAgICAgICAgICBmcy5lbnN1cmVGaWxlU3luYyhtb2RlbEZpbGVQYXRoKTtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMobW9kZWxGaWxlUGF0aCwgY2xhc3NDb2RlKTtcblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdpbmZvJywgJ0dlbmVyYXRlZCBlbnRpdHkgbW9kZWw6ICcgKyBtb2RlbEZpbGVQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgX2dlbmVyYXRlVmlld01vZGVsKHNjaGVtYSwgZGJTZXJ2aWNlKSB7ICAgICAgICBcbiAgICAgICAgXy5mb3JPd24oc2NoZW1hLnZpZXdzLCAodmlld0luZm8sIHZpZXdOYW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdCdWlsZGluZyB2aWV3OiAnICsgdmlld05hbWUpO1xuXG4gICAgICAgICAgICBsZXQgY2FwaXRhbGl6ZWQgPSBfLnVwcGVyRmlyc3Qodmlld05hbWUpO1xuXG4gICAgICAgICAgICBsZXQgYXN0ID0gSnNMYW5nLmFzdFByb2dyYW0oKTtcblxuICAgICAgICAgICAgSnNMYW5nLmFzdFB1c2hJbkJvZHkoYXN0LCBKc0xhbmcuYXN0UmVxdWlyZSgnTW93YScsICdtb3dhJykpO1xuICAgICAgICAgICAgSnNMYW5nLmFzdFB1c2hJbkJvZHkoYXN0LCBKc0xhbmcuYXN0VmFyRGVjbGFyZSgnVXRpbCcsIEpzTGFuZy5hc3RWYXJSZWYoJ01vd2EuVXRpbCcpLCB0cnVlKSk7XG4gICAgICAgICAgICBKc0xhbmcuYXN0UHVzaEluQm9keShhc3QsIEpzTGFuZy5hc3RWYXJEZWNsYXJlKCdfJywgSnNMYW5nLmFzdFZhclJlZignVXRpbC5fJyksIHRydWUpKTtcbiAgICAgICAgICAgIEpzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdCwgSnNMYW5nLmFzdFJlcXVpcmUoJ1ZpZXcnLCAnbW93YS9saWIvb29sb25nL3J1bnRpbWUvdmlldycpKTtcblxuICAgICAgICAgICAgbGV0IGNvbXBpbGVDb250ZXh0ID0gT29sVG9Bc3QuY3JlYXRlQ29tcGlsZUNvbnRleHQodmlld05hbWUsIGRiU2VydmljZS5zZXJ2aWNlSWQsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAgICAgY29tcGlsZUNvbnRleHQubW9kZWxWYXJzLmFkZCh2aWV3SW5mby5lbnRpdHkpO1xuXG4gICAgICAgICAgICBsZXQgcGFyYW1NZXRhO1xuXG4gICAgICAgICAgICBpZiAodmlld0luZm8ucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1NZXRhID0gdGhpcy5fcHJvY2Vzc1BhcmFtcyh2aWV3SW5mby5wYXJhbXMsIGNvbXBpbGVDb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHZpZXdNZXRhID0ge1xuICAgICAgICAgICAgICAgIGlzTGlzdDogdmlld0luZm8uaXNMaXN0LFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1NZXRhXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgdmlld0JvZHlUb3BvSWQgPSBPb2xUb0FzdC5jcmVhdGVUb3BvSWQoY29tcGlsZUNvbnRleHQsICckdmlldycpO1xuICAgICAgICAgICAgT29sVG9Bc3QuZGVwZW5kc09uKGNvbXBpbGVDb250ZXh0LCBjb21waWxlQ29udGV4dC5tYWluU3RhcnRJZCwgdmlld0JvZHlUb3BvSWQpO1xuXG4gICAgICAgICAgICBsZXQgdmlld01vZGVsZXIgPSByZXF1aXJlKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuL2Rhby92aWV3JywgZGJTZXJ2aWNlLmRiVHlwZSArICcuanMnKSk7XG4gICAgICAgICAgICBjb21waWxlQ29udGV4dC5hc3RNYXBbdmlld0JvZHlUb3BvSWRdID0gdmlld01vZGVsZXIoZGJTZXJ2aWNlLCB2aWV3TmFtZSwgdmlld0luZm8pO1xuICAgICAgICAgICAgT29sVG9Bc3QuYWRkQ29kZUJsb2NrKGNvbXBpbGVDb250ZXh0LCB2aWV3Qm9keVRvcG9JZCwge1xuICAgICAgICAgICAgICAgIHR5cGU6IE9vbFRvQXN0LkFTVF9CTEtfVklFV19PUEVSQVRJT05cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgcmV0dXJuVG9wb0lkID0gT29sVG9Bc3QuY3JlYXRlVG9wb0lkKGNvbXBpbGVDb250ZXh0LCAnJHJldHVybjp2YWx1ZScpO1xuICAgICAgICAgICAgT29sVG9Bc3QuZGVwZW5kc09uKGNvbXBpbGVDb250ZXh0LCB2aWV3Qm9keVRvcG9JZCwgcmV0dXJuVG9wb0lkKTtcbiAgICAgICAgICAgIE9vbFRvQXN0LmNvbXBpbGVSZXR1cm4ocmV0dXJuVG9wb0lkLCB7XG4gICAgICAgICAgICAgICAgXCJvb2xUeXBlXCI6IFwiT2JqZWN0UmVmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidmlld0RhdGFcIlxuICAgICAgICAgICAgfSwgY29tcGlsZUNvbnRleHQpO1xuXG4gICAgICAgICAgICBsZXQgZGVwcyA9IGNvbXBpbGVDb250ZXh0LnRvcG9Tb3J0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoJ0FsbCBkZXBlbmRlbmNpZXM6XFxuJyArIEpTT04uc3RyaW5naWZ5KGRlcHMsIG51bGwsIDIpKTtcblxuICAgICAgICAgICAgZGVwcyA9IGRlcHMuZmlsdGVyKGRlcCA9PiBjb21waWxlQ29udGV4dC5tYXBPZlRva2VuVG9NZXRhLmhhcyhkZXApKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoJ0FsbCBuZWNlc3Nhcnkgc291cmNlIGNvZGU6XFxuJyArIEpTT04uc3RyaW5naWZ5KGRlcHMsIG51bGwsIDIpKTtcblxuICAgICAgICAgICAgbGV0IGFzdERvTG9hZE1haW4gPSBbXG4gICAgICAgICAgICAgICAgSnNMYW5nLmFzdFZhckRlY2xhcmUoJyRtZXRhJywgSnNMYW5nLmFzdFZhclJlZigndGhpcy5tZXRhJyksIHRydWUsIGZhbHNlLCAnUmV0cmlldmluZyB0aGUgbWV0YSBkYXRhJylcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIF8uZWFjaChkZXBzLCBkZXAgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBhc3RNZXRhID0gY29tcGlsZUNvbnRleHQubWFwT2ZUb2tlblRvTWV0YS5nZXQoZGVwKTtcblxuICAgICAgICAgICAgICAgIGxldCBhc3RCbG9jayA9IGNvbXBpbGVDb250ZXh0LmFzdE1hcFtkZXBdO1xuICAgICAgICAgICAgICAgIGFzc2VydDogYXN0QmxvY2ssICdFbXB0eSBhc3QgYmxvY2snO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFzdE1ldGEudHlwZSA9PT0gJ01vZGlmaWVyQ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGdldEZpZWxkTmFtZShhc3RNZXRhLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhc3RDYWNoZSA9IEpzTGFuZy5hc3RBc3NpZ24oSnNMYW5nLmFzdFZhclJlZihhc3RNZXRhLnRhcmdldCksIGFzdEJsb2NrLCBgTW9kaWZ5aW5nICR7ZmllbGROYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBhc3REb0xvYWRNYWluLnB1c2goYXN0Q2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXN0RG9Mb2FkTWFpbiA9IGFzdERvTG9hZE1haW4uY29uY2F0KF8uY2FzdEFycmF5KGNvbXBpbGVDb250ZXh0LmFzdE1hcFtkZXBdKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHkoY29tcGlsZUNvbnRleHQubWFwT2ZGdW5jdG9yVG9GaWxlKSkge1xuICAgICAgICAgICAgICAgIF8uZm9yT3duKGNvbXBpbGVDb250ZXh0Lm1hcE9mRnVuY3RvclRvRmlsZSwgKGZpbGVOYW1lLCBmdW5jdGlvbk5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgSnNMYW5nLmFzdFB1c2hJbkJvZHkoYXN0LCBKc0xhbmcuYXN0UmVxdWlyZShmdW5jdGlvbk5hbWUsICcuJyArIGZpbGVOYW1lKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5KGNvbXBpbGVDb250ZXh0Lm5ld0Z1bmN0b3JGaWxlcykpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goY29tcGlsZUNvbnRleHQubmV3RnVuY3RvckZpbGVzLCBlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlRnVuY3Rpb25UZW1wbGF0ZUZpbGUoZGJTZXJ2aWNlLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEpzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdCwgSnNMYW5nLmFzdENsYXNzRGVjbGFyZShjYXBpdGFsaXplZCwgJ1ZpZXcnLCBbXG4gICAgICAgICAgICAgICAgSnNMYW5nLmFzdE1lbWJlck1ldGhvZCgnX2RvTG9hZCcsIE9iamVjdC5rZXlzKHBhcmFtTWV0YSksXG4gICAgICAgICAgICAgICAgICAgIGFzdERvTG9hZE1haW4sXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLCB0cnVlLCBmYWxzZSwgJ1BvcHVsYXRlIHZpZXcgZGF0YSdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdLCBgJHtjYXBpdGFsaXplZH0gdmlld2ApKTtcbiAgICAgICAgICAgIEpzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdCwgSnNMYW5nLmFzdEFzc2lnbihjYXBpdGFsaXplZCArICcubWV0YScsIEpzTGFuZy5hc3RWYWx1ZSh2aWV3TWV0YSkpKTtcbiAgICAgICAgICAgIEpzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdCwgSnNMYW5nLmFzdEFzc2lnbignbW9kdWxlLmV4cG9ydHMnLCBKc0xhbmcuYXN0VmFyUmVmKGNhcGl0YWxpemVkKSkpO1xuXG4gICAgICAgICAgICBsZXQgbW9kZWxGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm91dHB1dFBhdGgsIGRiU2VydmljZS5kYlR5cGUsIGRiU2VydmljZS5uYW1lLCAndmlld3MnLCB2aWV3TmFtZSArICcuanMnKTtcbiAgICAgICAgICAgIGZzLmVuc3VyZUZpbGVTeW5jKG1vZGVsRmlsZVBhdGgpO1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhtb2RlbEZpbGVQYXRoICsgJy5qc29uJywgSlNPTi5zdHJpbmdpZnkoYXN0LCBudWxsLCAyKSk7XG5cbiAgICAgICAgICAgIERhb01vZGVsZXIuX2V4cG9ydFNvdXJjZUNvZGUoYXN0LCBtb2RlbEZpbGVQYXRoKTtcblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdpbmZvJywgJ0dlbmVyYXRlZCB2aWV3IG1vZGVsOiAnICsgbW9kZWxGaWxlUGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgKi9cblxuICAgIF9wcm9jZXNzRmllbGRNb2RpZmllcnMoZW50aXR5LCBzaGFyZWRDb250ZXh0KSB7XG4gICAgICAgIGxldCBjb21waWxlQ29udGV4dCA9IE9vbFRvQXN0LmNyZWF0ZUNvbXBpbGVDb250ZXh0KGVudGl0eS5uYW1lLCB0aGlzLmxvZ2dlciwgc2hhcmVkQ29udGV4dCk7XG5cbiAgICAgICAgY29uc3QgYWxsRmluaXNoZWQgPSBPb2xUb0FzdC5jcmVhdGVUb3BvSWQoY29tcGlsZUNvbnRleHQsICdkb25lLicpO1xuXG4gICAgICAgIC8vbWFwIG9mIGZpZWxkIG5hbWUgdG8gZGVwZW5kZW5jaWVzXG4gICAgICAgIGxldCBmaWVsZFJlZmVyZW5jZXMgPSB7fTtcblxuICAgICAgICBfLmZvck93bihlbnRpdHkuZmllbGRzLCAoZmllbGQsIGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcG9JZCA9IE9vbFRvQXN0LmNvbXBpbGVGaWVsZChmaWVsZE5hbWUsIGZpZWxkLCBjb21waWxlQ29udGV4dCk7XG4gICAgICAgICAgICBPb2xUb0FzdC5kZXBlbmRzT24oY29tcGlsZUNvbnRleHQsIHRvcG9JZCwgYWxsRmluaXNoZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgZGVwcyA9IGNvbXBpbGVDb250ZXh0LnRvcG9Tb3J0LnNvcnQoKTtcbiAgICAgICAgZGVwcyA9IGRlcHMuZmlsdGVyKGRlcCA9PiBjb21waWxlQ29udGV4dC5tYXBPZlRva2VuVG9NZXRhLmhhcyhkZXApKTtcblxuICAgICAgICBsZXQgbWV0aG9kQm9keVZhbGlkYXRlQW5kRmlsbCA9IFtdLCBsYXN0RmllbGRzR3JvdXAsIFxuICAgICAgICAgICAgbWV0aG9kQm9keUNhY2hlID0gW10sIFxuICAgICAgICAgICAgbGFzdEJsb2NrLCBsYXN0QXN0VHlwZTsvLywgaGFzVmFsaWRhdG9yID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgX21lcmdlRG9WYWxpZGF0ZUFuZEZpbGxDb2RlID0gZnVuY3Rpb24gKGZpZWxkTmFtZSwgcmVmZXJlbmNlcywgYXN0Q2FjaGUsIHJlcXVpcmVUYXJnZXRGaWVsZCkgeyBcbiAgICAgICAgICAgIGxldCBmaWVsZHMgPSAocmVxdWlyZVRhcmdldEZpZWxkID8gWyBmaWVsZE5hbWUgXSA6IFtdKS5jb25jYXQocmVmZXJlbmNlcyk7XG4gICAgICAgICAgICBsZXQgY2hlY2tlciA9IGZpZWxkcy5qb2luKCcsJyk7XG5cbiAgICAgICAgICAgIGlmIChsYXN0RmllbGRzR3JvdXAgJiYgbGFzdEZpZWxkc0dyb3VwLmNoZWNrZXIgIT09IGNoZWNrZXIpIHtcbiAgICAgICAgICAgICAgICBtZXRob2RCb2R5VmFsaWRhdGVBbmRGaWxsID0gbWV0aG9kQm9keVZhbGlkYXRlQW5kRmlsbC5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIFNuaXBwZXRzLl9maWVsZFJlcXVpcmVtZW50Q2hlY2sobGFzdEZpZWxkc0dyb3VwLmZpZWxkTmFtZSwgbGFzdEZpZWxkc0dyb3VwLnJlZmVyZW5jZXMsIG1ldGhvZEJvZHlDYWNoZSwgbGFzdEZpZWxkc0dyb3VwLnJlcXVpcmVUYXJnZXRGaWVsZClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG1ldGhvZEJvZHlDYWNoZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZXRob2RCb2R5Q2FjaGUgPSBtZXRob2RCb2R5Q2FjaGUuY29uY2F0KGFzdENhY2hlKTtcbiAgICAgICAgICAgIGxhc3RGaWVsZHNHcm91cCA9IHtcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICByZXF1aXJlVGFyZ2V0RmllbGQsICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoZWNrZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9jb25zb2xlLmRpcihjb21waWxlQ29udGV4dC5hc3RNYXBbJ21vYmlsZX5pc01vYmlsZVBob25lOmFyZ1sxXXw+c3RyaW5nRGFzaGVyaXplJ10sIHsgZGVwdGg6IDggfSk7IFxuXG4gICAgICAgIF8uZWFjaChkZXBzLCAoZGVwLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgc291cmNlTWFwID0gY29tcGlsZUNvbnRleHQubWFwT2ZUb2tlblRvTWV0YS5nZXQoZGVwKTtcbiAgICAgICAgICAgIGxldCBhc3RCbG9jayA9IGNvbXBpbGVDb250ZXh0LmFzdE1hcFtkZXBdO1xuXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RmllbGROYW1lID0gZ2V0RmllbGROYW1lKHNvdXJjZU1hcC50YXJnZXQpOyAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoc291cmNlTWFwLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGRSZWZlcmVuY2UgPSBmaWVsZFJlZmVyZW5jZXNbdGFyZ2V0RmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlc1t0YXJnZXRGaWVsZE5hbWVdID0gZmllbGRSZWZlcmVuY2UgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzb3VyY2VNYXAucmVmZXJlbmNlcy5mb3JFYWNoKHJlZiA9PiB7IGlmIChmaWVsZFJlZmVyZW5jZS5pbmRleE9mKHJlZikgPT09IC0xKSBmaWVsZFJlZmVyZW5jZS5wdXNoKHJlZik7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgYXN0QmxvY2sgPSBjaGFpbkNhbGwobGFzdEJsb2NrLCBsYXN0QXN0VHlwZSwgYXN0QmxvY2ssIHNvdXJjZU1hcC50eXBlKTtcbiAgICAgICAgICAgICAgICBsYXN0QmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpIDwgZGVwcy5sZW5ndGgtMSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VHlwZSA9IGNvbXBpbGVDb250ZXh0Lm1hcE9mVG9rZW5Ub01ldGEuZ2V0KGRlcHNbaSsxXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFpbmFibGUoc291cmNlTWFwLCBuZXh0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrID0gYXN0QmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RBc3RUeXBlID0gc291cmNlTWFwLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmIChzb3VyY2VNYXAudHlwZSA9PT0gT29sVG9Bc3QuQVNUX0JMS19WQUxJREFUT1JfQ0FMTCkge1xuICAgICAgICAgICAgICAgIC8vaGFzVmFsaWRhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgYXN0Q2FjaGUgPSBTbmlwcGV0cy5fdmFsaWRhdGVDaGVjayh0YXJnZXRGaWVsZE5hbWUsIGFzdEJsb2NrKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBfbWVyZ2VEb1ZhbGlkYXRlQW5kRmlsbENvZGUodGFyZ2V0RmllbGROYW1lLCBzb3VyY2VNYXAucmVmZXJlbmNlcywgYXN0Q2FjaGUsIHRydWUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcC50eXBlID09PSBPb2xUb0FzdC5BU1RfQkxLX1BST0NFU1NPUl9DQUxMKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzdENhY2hlID0gSnNMYW5nLmFzdEFzc2lnbihKc0xhbmcuYXN0VmFyUmVmKHNvdXJjZU1hcC50YXJnZXQsIHRydWUpLCBhc3RCbG9jaywgYFByb2Nlc3NpbmcgXCIke3RhcmdldEZpZWxkTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIF9tZXJnZURvVmFsaWRhdGVBbmRGaWxsQ29kZSh0YXJnZXRGaWVsZE5hbWUsIHNvdXJjZU1hcC5yZWZlcmVuY2VzLCBhc3RDYWNoZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcC50eXBlID09PSBPb2xUb0FzdC5BU1RfQkxLX0FDVElWQVRPUl9DQUxMKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzdENhY2hlID0gSnNMYW5nLmFzdEFzc2lnbihKc0xhbmcuYXN0VmFyUmVmKHNvdXJjZU1hcC50YXJnZXQsIHRydWUpLCBhc3RCbG9jaywgYEFjdGl2YXRpbmcgXCIke3RhcmdldEZpZWxkTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIF9tZXJnZURvVmFsaWRhdGVBbmRGaWxsQ29kZSh0YXJnZXRGaWVsZE5hbWUsIHNvdXJjZU1hcC5yZWZlcmVuY2VzLCBhc3RDYWNoZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIGJlIGltcGxlbWVudGVkLicpO1xuICAgICAgICAgICAgICAgIC8vYXN0QmxvY2sgPSBfLmNhc3RBcnJheShhc3RCbG9jayk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vX21lcmdlRG9WYWxpZGF0ZUFuZEZpbGxDb2RlKHRhcmdldEZpZWxkTmFtZSwgW10sIGFzdEJsb2NrKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvKiBDaGFuZ2VkIHRvIHRocm93IGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgZXJyb3Igb2JqZWN0XG4gICAgICAgIGlmIChoYXNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGxldCBkZWNsYXJlID0gSnNMYW5nLmFzdFZhckRlY2xhcmUodmFsaWRTdGF0ZU5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIG1ldGhvZEJvZHlDcmVhdGUudW5zaGlmdChkZWNsYXJlKTtcbiAgICAgICAgICAgIG1ldGhvZEJvZHlVcGRhdGUudW5zaGlmdChkZWNsYXJlKTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgICAgIGlmICghXy5pc0VtcHR5KG1ldGhvZEJvZHlDYWNoZSkpIHtcbiAgICAgICAgICAgIG1ldGhvZEJvZHlWYWxpZGF0ZUFuZEZpbGwgPSBtZXRob2RCb2R5VmFsaWRhdGVBbmRGaWxsLmNvbmNhdChcbiAgICAgICAgICAgICAgICBTbmlwcGV0cy5fZmllbGRSZXF1aXJlbWVudENoZWNrKGxhc3RGaWVsZHNHcm91cC5maWVsZE5hbWUsIFxuICAgICAgICAgICAgICAgICAgICBsYXN0RmllbGRzR3JvdXAucmVmZXJlbmNlcywgXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZEJvZHlDYWNoZSwgXG4gICAgICAgICAgICAgICAgICAgIGxhc3RGaWVsZHNHcm91cC5yZXF1aXJlVGFyZ2V0RmllbGRcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gICAgICBcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIGxldCBhc3QgPSBKc0xhbmcuYXN0UHJvZ3JhbShmYWxzZSk7XG4gICAgICAgIEpzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdCwgSnNMYW5nLmFzdENsYXNzRGVjbGFyZSgnQWJjJywgJ01vZGVsJywgW1xuICAgICAgICAgICAgSnNMYW5nLmFzdE1lbWJlck1ldGhvZChhc3luY01ldGhvZE5hbWluZygncHJlcGFyZUVudGl0eURhdGFfJyksIFsgJ2NvbnRleHQnIF0sXG4gICAgICAgICAgICBTbmlwcGV0cy5fZG9WYWxpZGF0ZUFuZEZpbGxIZWFkZXIuY29uY2F0KG1ldGhvZEJvZHlWYWxpZGF0ZUFuZEZpbGwpLmNvbmNhdChbIEpzTGFuZy5hc3RSZXR1cm4oSnNMYW5nLmFzdElkKCdjb250ZXh0JykpIF0pLFxuICAgICAgICAgICAgZmFsc2UsIHRydWUsIHRydWVcbiAgICAgICAgKV0sICdjb21tZW50JykpO1xuICAgICAgICAqL1xuXG4gICAgICAgIHJldHVybiB7IGFzdDogSnNMYW5nLmFzdE1lbWJlck1ldGhvZChhc3luY01ldGhvZE5hbWluZygnYXBwbHlNb2RpZmllcnMnKSwgWyAnY29udGV4dCcsICdpc1VwZGF0aW5nJyBdLFxuICAgICAgICAgICAgU25pcHBldHMuX2FwcGx5TW9kaWZpZXJzSGVhZGVyLmNvbmNhdChtZXRob2RCb2R5VmFsaWRhdGVBbmRGaWxsKS5jb25jYXQoWyBKc0xhbmcuYXN0UmV0dXJuKEpzTGFuZy5hc3RJZCgnY29udGV4dCcpKSBdKSxcbiAgICAgICAgICAgIGZhbHNlLCB0cnVlLCB0cnVlLCAnQXBwbHlpbmcgcHJlZGVmaW5lZCBtb2RpZmllcnMgdG8gZW50aXR5IGZpZWxkcy4nXG4gICAgICAgICksIGZpZWxkUmVmZXJlbmNlcyB9O1xuICAgIH1cblxuICAgIF9nZW5lcmF0ZUZ1bmN0aW9uVGVtcGxhdGVGaWxlKHNjaGVtYSwgeyBmdW5jdGlvbk5hbWUsIGZ1bmN0b3JUeXBlLCBmaWxlTmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGxldCBmaWxlUGF0aCA9IHBhdGgucmVzb2x2ZShcbiAgICAgICAgICAgIHRoaXMub3V0cHV0UGF0aCxcbiAgICAgICAgICAgIHNjaGVtYS5uYW1lLFxuICAgICAgICAgICAgZmlsZU5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIC8vdG9kbzogYW5hbHlzZSBjb2RlLCBjb21wYXJlIGFyZ3VtZW50c1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdpbmZvJywgYCR7IF8udXBwZXJGaXJzdChmdW5jdG9yVHlwZSkgfSBcIiR7ZmlsZU5hbWV9XCIgZXhpc3RzLiBGaWxlIGdlbmVyYXRpbmcgc2tpcHBlZC5gKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFzdCA9IEpzTGFuZy5hc3RQcm9ncmFtKCk7XG4gICAgICAgIFxuICAgICAgICBKc0xhbmcuYXN0UHVzaEluQm9keShhc3QsIEpzTGFuZy5hc3RGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGFyZ3MsIE9PTF9NT0RJRklFUl9SRVRVUk5bZnVuY3RvclR5cGVdKGFyZ3MpKSk7XG4gICAgICAgIEpzTGFuZy5hc3RQdXNoSW5Cb2R5KGFzdCwgSnNMYW5nLmFzdEFzc2lnbignbW9kdWxlLmV4cG9ydHMnLCBKc0xhbmcuYXN0VmFyUmVmKGZ1bmN0aW9uTmFtZSkpKTtcblxuICAgICAgICBmcy5lbnN1cmVGaWxlU3luYyhmaWxlUGF0aCk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIEpzTGFuZy5hc3RUb0NvZGUoYXN0KSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnaW5mbycsIGBHZW5lcmF0ZWQgJHsgZnVuY3RvclR5cGUgfSBmaWxlOiAke2ZpbGVQYXRofWApO1xuICAgIH1cblxuICAgIF9idWlsZEludGVyZmFjZXMoZW50aXR5LCBtb2RlbE1ldGFJbml0LCBzaGFyZWRDb250ZXh0KSB7XG4gICAgICAgIGxldCBhc3QgPSBbXTtcblxuICAgICAgICBfLmZvck93bihlbnRpdHkuaW50ZXJmYWNlcywgKG1ldGhvZCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQnVpbGRpbmcgaW50ZXJmYWNlOiAnICsgbmFtZSk7XG5cbiAgICAgICAgICAgIGxldCBhc3RCb2R5ID0gW1xuICAgICAgICAgICAgICAgIEpzTGFuZy5hc3RWYXJEZWNsYXJlKCckbWV0YScsIEpzTGFuZy5hc3RWYXJSZWYoJ3RoaXMubWV0YS5pbnRlcmZhY2VzLicgKyBuYW1lKSwgdHJ1ZSwgZmFsc2UsICdSZXRyaWV2aW5nIHRoZSBtZXRhIGRhdGEnKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IGNvbXBpbGVDb250ZXh0ID0gT29sVG9Bc3QuY3JlYXRlQ29tcGlsZUNvbnRleHQoZW50aXR5Lm5hbWUsIHRoaXMubG9nZ2VyLCBzaGFyZWRDb250ZXh0KTtcblxuICAgICAgICAgICAgLy9zY2FuIGFsbCB1c2VkIG1vZGVscyBpbiBhZHZhbmNlXG4gICAgICAgICAgICBfLmVhY2gobWV0aG9kLmltcGxlbWVudGF0aW9uLCAob3BlcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcGlsZUNvbnRleHQubW9kZWxWYXJzLmFkZChvcGVyYXRpb24ubW9kZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBwYXJhbU1ldGE7XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QuYWNjZXB0KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1NZXRhID0gdGhpcy5fcHJvY2Vzc1BhcmFtcyhtZXRob2QuYWNjZXB0LCBjb21waWxlQ29udGV4dCk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIC8vbWV0YWRhdGFcbiAgICAgICAgICAgIG1vZGVsTWV0YUluaXRbJ2ludGVyZmFjZXMnXSB8fCAobW9kZWxNZXRhSW5pdFsnaW50ZXJmYWNlcyddID0ge30pO1xuICAgICAgICAgICAgbW9kZWxNZXRhSW5pdFsnaW50ZXJmYWNlcyddW25hbWVdID0geyBwYXJhbXM6IE9iamVjdC52YWx1ZXMocGFyYW1NZXRhKSB9O1xuXG4gICAgICAgICAgICBfLmVhY2gobWV0aG9kLmltcGxlbWVudGF0aW9uLCAob3BlcmF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vbGV0IGxhc3RUb3BvSWQgPSBcbiAgICAgICAgICAgICAgICBPb2xUb0FzdC5jb21waWxlRGJPcGVyYXRpb24oaW5kZXgsIG9wZXJhdGlvbiwgY29tcGlsZUNvbnRleHQsIGNvbXBpbGVDb250ZXh0Lm1haW5TdGFydElkKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1ldGhvZC5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBPb2xUb0FzdC5jb21waWxlRXhjZXB0aW9uYWxSZXR1cm4obWV0aG9kLnJldHVybiwgY29tcGlsZUNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVwcyA9IGNvbXBpbGVDb250ZXh0LnRvcG9Tb3J0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoJ0FsbCBkZXBlbmRlbmNpZXM6XFxuJyArIEpTT04uc3RyaW5naWZ5KGRlcHMsIG51bGwsIDIpKTtcblxuICAgICAgICAgICAgZGVwcyA9IGRlcHMuZmlsdGVyKGRlcCA9PiBjb21waWxlQ29udGV4dC5tYXBPZlRva2VuVG9NZXRhLmhhcyhkZXApKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoJ0FsbCBuZWNlc3Nhcnkgc291cmNlIGNvZGU6XFxuJyArIEpTT04uc3RyaW5naWZ5KGRlcHMsIG51bGwsIDIpKTtcblxuICAgICAgICAgICAgXy5lYWNoKGRlcHMsIGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZU1hcCA9IGNvbXBpbGVDb250ZXh0Lm1hcE9mVG9rZW5Ub01ldGEuZ2V0KGRlcCk7XG4gICAgICAgICAgICAgICAgbGV0IGFzdEJsb2NrID0gY29tcGlsZUNvbnRleHQuYXN0TWFwW2RlcF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKCdDb2RlIHBvaW50IFwiJyArIGRlcCArICdcIjpcXG4nICsgSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwLCBudWxsLCAyKSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RmllbGROYW1lID0gc291cmNlTWFwLnRhcmdldDsgLy9nZXRGaWVsZE5hbWUoc291cmNlTWFwLnRhcmdldCk7ICAgICAgXG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlTWFwLnR5cGUgPT09IE9vbFRvQXN0LkFTVF9CTEtfVkFMSURBVE9SX0NBTEwpIHsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBhc3RCbG9jayA9IFNuaXBwZXRzLl92YWxpZGF0ZUNoZWNrKHRhcmdldEZpZWxkTmFtZSwgYXN0QmxvY2spO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXAudHlwZSA9PT0gT29sVG9Bc3QuQVNUX0JMS19QUk9DRVNTT1JfQ0FMTCkge1xuICAgICAgICAgICAgICAgICAgICBhc3RCbG9jayA9IEpzTGFuZy5hc3RBc3NpZ24oSnNMYW5nLmFzdFZhclJlZihzb3VyY2VNYXAudGFyZ2V0LCB0cnVlKSwgYXN0QmxvY2ssIGBQcm9jZXNzaW5nIFwiJHt0YXJnZXRGaWVsZE5hbWV9XCJgKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcC50eXBlID09PSBPb2xUb0FzdC5BU1RfQkxLX0FDVElWQVRPUl9DQUxMKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdEJsb2NrID0gSnNMYW5nLmFzdEFzc2lnbihKc0xhbmcuYXN0VmFyUmVmKHNvdXJjZU1hcC50YXJnZXQsIHRydWUpLCBhc3RCbG9jaywgYEFjdGl2YXRpbmcgXCIke3RhcmdldEZpZWxkTmFtZX1cImApOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFzdEJvZHkgPSBhc3RCb2R5LmNvbmNhdChfLmNhc3RBcnJheShhc3RCbG9jaykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGFzdC5wdXNoKEpzTGFuZy5hc3RNZW1iZXJNZXRob2QoYXN5bmNNZXRob2ROYW1pbmcobmFtZSksIE9iamVjdC5rZXlzKHBhcmFtTWV0YSksIGFzdEJvZHksIGZhbHNlLCB0cnVlLCB0cnVlLCByZXBsYWNlQWxsKF8ua2ViYWJDYXNlKG5hbWUpLCAnLScsICcgJykpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuXG4gICAgX3Byb2Nlc3NQYXJhbXMoYWNjZXB0UGFyYW1zLCBjb21waWxlQ29udGV4dCkge1xuICAgICAgICBsZXQgcGFyYW1NZXRhID0ge307XG5cbiAgICAgICAgYWNjZXB0UGFyYW1zLmZvckVhY2goKHBhcmFtLCBpKSA9PiB7XG4gICAgICAgICAgICBPb2xUb0FzdC5jb21waWxlUGFyYW0oaSwgcGFyYW0sIGNvbXBpbGVDb250ZXh0KTtcbiAgICAgICAgICAgIHBhcmFtTWV0YVtwYXJhbS5uYW1lXSA9IHBhcmFtO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1NZXRhO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGFvTW9kZWxlcjsiXX0=