"use strict";

require("source-map-support/register");

const {
  _
} = require('rk-utils');

const Rules = require('../../enum/Rules');

const {
  DATETIME
} = require('../types');

const {
  OolongUsageError
} = require('../Errors');

function getConnector(entityModel, feature) {
  let app = entityModel.db.app;

  if (!app) {
    entityModel.db.connector.log('warn', `"changeLog" feature does not work when used without a service container app.`);
    return true;
  }

  return app.getService(feature.dataSource);
}

async function createLogEntry_(entityModel, feature, context, operation) {
  let logEntry = {
    entity: entityModel.meta.name,
    operation,
    which: context.queryKey,
    changedAt: DATETIME.typeObject.local()
  };

  if (operation !== 'delete') {
    logEntry.data = context.raw;
  }

  if (feature.withUser) {
    let user = entityModel.getValueFromContext(context, feature.withUser);

    if (_.isNil(user)) {
      throw new OolongUsageError(`Cannot get value of [${feature.withUser}] from context.`);
    }

    console.log('context.options', context.options);
    console.log('user', user);
    logEntry.changedBy = user;
  }

  let clConnector = getConnector(entityModel, feature);
  await clConnector.insertOne_(feature.storeEntity, logEntry);
}

module.exports = {
  [Rules.RULE_AFTER_CREATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'create'),
  [Rules.RULE_AFTER_UPDATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'update'),
  [Rules.RULE_AFTER_DELETE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'delete')
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydW50aW1lL2VudGl0eUZlYXR1cmVzL2NoYW5nZUxvZy5qcyJdLCJuYW1lcyI6WyJfIiwicmVxdWlyZSIsIlJ1bGVzIiwiREFURVRJTUUiLCJPb2xvbmdVc2FnZUVycm9yIiwiZ2V0Q29ubmVjdG9yIiwiZW50aXR5TW9kZWwiLCJmZWF0dXJlIiwiYXBwIiwiZGIiLCJjb25uZWN0b3IiLCJsb2ciLCJnZXRTZXJ2aWNlIiwiZGF0YVNvdXJjZSIsImNyZWF0ZUxvZ0VudHJ5XyIsImNvbnRleHQiLCJvcGVyYXRpb24iLCJsb2dFbnRyeSIsImVudGl0eSIsIm1ldGEiLCJuYW1lIiwid2hpY2giLCJxdWVyeUtleSIsImNoYW5nZWRBdCIsInR5cGVPYmplY3QiLCJsb2NhbCIsImRhdGEiLCJyYXciLCJ3aXRoVXNlciIsInVzZXIiLCJnZXRWYWx1ZUZyb21Db250ZXh0IiwiaXNOaWwiLCJjb25zb2xlIiwib3B0aW9ucyIsImNoYW5nZWRCeSIsImNsQ29ubmVjdG9yIiwiaW5zZXJ0T25lXyIsInN0b3JlRW50aXR5IiwibW9kdWxlIiwiZXhwb3J0cyIsIlJVTEVfQUZURVJfQ1JFQVRFIiwiUlVMRV9BRlRFUl9VUERBVEUiLCJSVUxFX0FGVEVSX0RFTEVURSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxNQUFNO0FBQUVBLEVBQUFBO0FBQUYsSUFBUUMsT0FBTyxDQUFDLFVBQUQsQ0FBckI7O0FBQ0EsTUFBTUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsa0JBQUQsQ0FBckI7O0FBQ0EsTUFBTTtBQUFFRSxFQUFBQTtBQUFGLElBQWVGLE9BQU8sQ0FBQyxVQUFELENBQTVCOztBQUNBLE1BQU07QUFBRUcsRUFBQUE7QUFBRixJQUF1QkgsT0FBTyxDQUFDLFdBQUQsQ0FBcEM7O0FBRUEsU0FBU0ksWUFBVCxDQUFzQkMsV0FBdEIsRUFBbUNDLE9BQW5DLEVBQTRDO0FBQ3hDLE1BQUlDLEdBQUcsR0FBR0YsV0FBVyxDQUFDRyxFQUFaLENBQWVELEdBQXpCOztBQUVBLE1BQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ05GLElBQUFBLFdBQVcsQ0FBQ0csRUFBWixDQUFlQyxTQUFmLENBQXlCQyxHQUF6QixDQUE2QixNQUE3QixFQUFzQyw4RUFBdEM7QUFDQSxXQUFPLElBQVA7QUFDSDs7QUFFRCxTQUFPSCxHQUFHLENBQUNJLFVBQUosQ0FBZUwsT0FBTyxDQUFDTSxVQUF2QixDQUFQO0FBQ0g7O0FBRUQsZUFBZUMsZUFBZixDQUErQlIsV0FBL0IsRUFBNENDLE9BQTVDLEVBQXFEUSxPQUFyRCxFQUE4REMsU0FBOUQsRUFBeUU7QUFDckUsTUFBSUMsUUFBUSxHQUFHO0FBQ1hDLElBQUFBLE1BQU0sRUFBRVosV0FBVyxDQUFDYSxJQUFaLENBQWlCQyxJQURkO0FBRVhKLElBQUFBLFNBRlc7QUFHWEssSUFBQUEsS0FBSyxFQUFFTixPQUFPLENBQUNPLFFBSEo7QUFJWEMsSUFBQUEsU0FBUyxFQUFFcEIsUUFBUSxDQUFDcUIsVUFBVCxDQUFvQkMsS0FBcEI7QUFKQSxHQUFmOztBQU9BLE1BQUlULFNBQVMsS0FBSyxRQUFsQixFQUE0QjtBQUN4QkMsSUFBQUEsUUFBUSxDQUFDUyxJQUFULEdBQWdCWCxPQUFPLENBQUNZLEdBQXhCO0FBQ0g7O0FBRUQsTUFBSXBCLE9BQU8sQ0FBQ3FCLFFBQVosRUFBc0I7QUFDbEIsUUFBSUMsSUFBSSxHQUFHdkIsV0FBVyxDQUFDd0IsbUJBQVosQ0FBZ0NmLE9BQWhDLEVBQXlDUixPQUFPLENBQUNxQixRQUFqRCxDQUFYOztBQUNBLFFBQUk1QixDQUFDLENBQUMrQixLQUFGLENBQVFGLElBQVIsQ0FBSixFQUFtQjtBQUNmLFlBQU0sSUFBSXpCLGdCQUFKLENBQXNCLHdCQUF1QkcsT0FBTyxDQUFDcUIsUUFBUyxpQkFBOUQsQ0FBTjtBQUNIOztBQUVESSxJQUFBQSxPQUFPLENBQUNyQixHQUFSLENBQVksaUJBQVosRUFBK0JJLE9BQU8sQ0FBQ2tCLE9BQXZDO0FBQ0FELElBQUFBLE9BQU8sQ0FBQ3JCLEdBQVIsQ0FBWSxNQUFaLEVBQW9Ca0IsSUFBcEI7QUFFQVosSUFBQUEsUUFBUSxDQUFDaUIsU0FBVCxHQUFxQkwsSUFBckI7QUFDSDs7QUFFRCxNQUFJTSxXQUFXLEdBQUc5QixZQUFZLENBQUNDLFdBQUQsRUFBY0MsT0FBZCxDQUE5QjtBQUNBLFFBQU00QixXQUFXLENBQUNDLFVBQVosQ0FBdUI3QixPQUFPLENBQUM4QixXQUEvQixFQUE0Q3BCLFFBQTVDLENBQU47QUFDSDs7QUFPRHFCLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjtBQUNiLEdBQUNyQyxLQUFLLENBQUNzQyxpQkFBUCxHQUEyQixDQUFDakMsT0FBRCxFQUFVRCxXQUFWLEVBQXVCUyxPQUF2QixLQUFtQ0QsZUFBZSxDQUFDUixXQUFELEVBQWNDLE9BQWQsRUFBdUJRLE9BQXZCLEVBQWdDLFFBQWhDLENBRGhFO0FBRWIsR0FBQ2IsS0FBSyxDQUFDdUMsaUJBQVAsR0FBMkIsQ0FBQ2xDLE9BQUQsRUFBVUQsV0FBVixFQUF1QlMsT0FBdkIsS0FBbUNELGVBQWUsQ0FBQ1IsV0FBRCxFQUFjQyxPQUFkLEVBQXVCUSxPQUF2QixFQUFnQyxRQUFoQyxDQUZoRTtBQUdiLEdBQUNiLEtBQUssQ0FBQ3dDLGlCQUFQLEdBQTJCLENBQUNuQyxPQUFELEVBQVVELFdBQVYsRUFBdUJTLE9BQXZCLEtBQW1DRCxlQUFlLENBQUNSLFdBQUQsRUFBY0MsT0FBZCxFQUF1QlEsT0FBdkIsRUFBZ0MsUUFBaEM7QUFIaEUsQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgeyBfIH0gPSByZXF1aXJlKCdyay11dGlscycpO1xuY29uc3QgUnVsZXMgPSByZXF1aXJlKCcuLi8uLi9lbnVtL1J1bGVzJyk7XG5jb25zdCB7IERBVEVUSU1FIH0gPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgeyBPb2xvbmdVc2FnZUVycm9yIH0gPSByZXF1aXJlKCcuLi9FcnJvcnMnKVxuXG5mdW5jdGlvbiBnZXRDb25uZWN0b3IoZW50aXR5TW9kZWwsIGZlYXR1cmUpIHtcbiAgICBsZXQgYXBwID0gZW50aXR5TW9kZWwuZGIuYXBwO1xuICAgICAgICBcbiAgICBpZiAoIWFwcCkge1xuICAgICAgICBlbnRpdHlNb2RlbC5kYi5jb25uZWN0b3IubG9nKCd3YXJuJywgYFwiY2hhbmdlTG9nXCIgZmVhdHVyZSBkb2VzIG5vdCB3b3JrIHdoZW4gdXNlZCB3aXRob3V0IGEgc2VydmljZSBjb250YWluZXIgYXBwLmApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBhcHAuZ2V0U2VydmljZShmZWF0dXJlLmRhdGFTb3VyY2UpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVMb2dFbnRyeV8oZW50aXR5TW9kZWwsIGZlYXR1cmUsIGNvbnRleHQsIG9wZXJhdGlvbikge1xuICAgIGxldCBsb2dFbnRyeSA9IHtcbiAgICAgICAgZW50aXR5OiBlbnRpdHlNb2RlbC5tZXRhLm5hbWUsXG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgd2hpY2g6IGNvbnRleHQucXVlcnlLZXksIFxuICAgICAgICBjaGFuZ2VkQXQ6IERBVEVUSU1FLnR5cGVPYmplY3QubG9jYWwoKVxuICAgIH07XG5cbiAgICBpZiAob3BlcmF0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICBsb2dFbnRyeS5kYXRhID0gY29udGV4dC5yYXc7XG4gICAgfVxuXG4gICAgaWYgKGZlYXR1cmUud2l0aFVzZXIpIHtcbiAgICAgICAgbGV0IHVzZXIgPSBlbnRpdHlNb2RlbC5nZXRWYWx1ZUZyb21Db250ZXh0KGNvbnRleHQsIGZlYXR1cmUud2l0aFVzZXIpO1xuICAgICAgICBpZiAoXy5pc05pbCh1c2VyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9vbG9uZ1VzYWdlRXJyb3IoYENhbm5vdCBnZXQgdmFsdWUgb2YgWyR7ZmVhdHVyZS53aXRoVXNlcn1dIGZyb20gY29udGV4dC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdjb250ZXh0Lm9wdGlvbnMnLCBjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBjb25zb2xlLmxvZygndXNlcicsIHVzZXIpO1xuXG4gICAgICAgIGxvZ0VudHJ5LmNoYW5nZWRCeSA9IHVzZXI7XG4gICAgfVxuXG4gICAgbGV0IGNsQ29ubmVjdG9yID0gZ2V0Q29ubmVjdG9yKGVudGl0eU1vZGVsLCBmZWF0dXJlKTtcbiAgICBhd2FpdCBjbENvbm5lY3Rvci5pbnNlcnRPbmVfKGZlYXR1cmUuc3RvcmVFbnRpdHksIGxvZ0VudHJ5KTtcbn1cblxuLyoqXG4gKiBBIHJ1bGUgc3BlY2lmaWVzIHRoZSBjaGFuZ2Ugb2Ygc3RhdGUgd2lsbCBiZSB0cmFja2VkIGF1dG9tYXRpY2FsbHkuXG4gKiBAbW9kdWxlIEVudGl0eUZlYXR1cmVSdW50aW1lX0NoYW5nZUxvZ1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFtSdWxlcy5SVUxFX0FGVEVSX0NSRUFURV06IChmZWF0dXJlLCBlbnRpdHlNb2RlbCwgY29udGV4dCkgPT4gY3JlYXRlTG9nRW50cnlfKGVudGl0eU1vZGVsLCBmZWF0dXJlLCBjb250ZXh0LCAnY3JlYXRlJyksXG4gICAgW1J1bGVzLlJVTEVfQUZURVJfVVBEQVRFXTogKGZlYXR1cmUsIGVudGl0eU1vZGVsLCBjb250ZXh0KSA9PiBjcmVhdGVMb2dFbnRyeV8oZW50aXR5TW9kZWwsIGZlYXR1cmUsIGNvbnRleHQsICd1cGRhdGUnKSxcbiAgICBbUnVsZXMuUlVMRV9BRlRFUl9ERUxFVEVdOiAoZmVhdHVyZSwgZW50aXR5TW9kZWwsIGNvbnRleHQpID0+IGNyZWF0ZUxvZ0VudHJ5XyhlbnRpdHlNb2RlbCwgZmVhdHVyZSwgY29udGV4dCwgJ2RlbGV0ZScpXG59OyJdfQ==