"use strict";

require("source-map-support/register");

const path = require('path');

const {
  _,
  fs,
  eachAsync_,
  pascalCase
} = require('rk-utils');

class MySQLMigration {
  constructor(context, schemaName, connector) {
    this.logger = context.logger;
    this.modelPath = context.modelPath;
    this.scriptSourcePath = context.scriptSourcePath;
    this.schemaName = schemaName;
    this.connector = connector;
    this.dbScriptPath = path.join(this.scriptSourcePath, this.connector.driver, this.connector.database);
  }

  async reset_() {
    return this.connector.execute_(`DROP DATABASE IF EXISTS ??`, [this.connector.database], {
      createDatabase: true
    });
  }

  async create_() {
    let sqlFiles = ['entities.sql', 'relations.sql', 'procedures.sql'];
    let result = await this.connector.execute_('CREATE DATABASE IF NOT EXISTS ??', [this.connector.database], {
      createDatabase: true
    });

    if (result.warningStatus == 0) {
      this.logger.log('info', `Created database "${this.connector.database}".`);
    } else {
      this.logger.log('warn', `Database "${this.connector.database}" exists.`);
    }

    return eachAsync_(sqlFiles, async file => {
      let sqlFile = path.join(this.dbScriptPath, file);

      if (!fs.existsSync(sqlFile)) {
        throw new Error(`Database script "${sqlFile}" not found. Try run "oolong build" first.`);
      }

      let sql = _.trim(fs.readFileSync(sqlFile, {
        encoding: 'utf8'
      }));

      if (sql) {
        result = _.castArray((await this.connector.execute_(sql, null, {
          multipleStatements: 1
        })));

        let warningRows = _.reduce(result, (sum, row) => {
          sum += row.warningStatus;
          return sum;
        }, 0);

        if (warningRows > 0) {
          this.logger.log('warn', `${warningRows} warning(s) reported while running "${file}".`);
        } else {
          this.logger.log('info', `Database scripts "${sqlFile}" run successfully.`);
        }
      }
    });
  }

  async load_(dataFile) {
    let ext = path.extname(dataFile);

    if (ext === '.json') {
      let data = fs.readJsonSync(dataFile, {
        encoding: 'utf8'
      });
      let className = pascalCase(this.schemaName);

      let Db = require(path.join(this.modelPath, className));

      let db = new Db(this.connector.connectionString, this.connector.options);

      try {
        await db.connector.execute_('SET FOREIGN_KEY_CHECKS=0;');
        await eachAsync_(data, async (records, entityName) => {
          let Model = db.model(entityName);
          let items = Array.isArray(records) ? records : [records];
          return eachAsync_(items, async item => {
            let model = await Model.create_(item);
            this.logger.log('verbose', `Created a(n) ${entityName} entity: ${JSON.stringify(model.$pkValues)}`);
          });
        });
        await db.connector.execute_('SET FOREIGN_KEY_CHECKS=1;');
      } catch (error) {
        throw error;
      } finally {
        await db.close_();
      }
    } else if (ext === '.sql') {
      let sql = fs.readFileSync(dataFile, {
        encoding: 'utf8'
      });
      let result = await this.connector.execute_(sql, null, {
        multipleStatements: 1
      });
      this.logger.log('verbose', `Executed SQL file: ${dataFile}`, result);
    } else {
      throw new Error('Unsupported data file format.');
    }
  }

}

module.exports = MySQLMigration;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9taWdyYXRpb24vbXlzcWwuanMiXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJfIiwiZnMiLCJlYWNoQXN5bmNfIiwicGFzY2FsQ2FzZSIsIk15U1FMTWlncmF0aW9uIiwiY29uc3RydWN0b3IiLCJjb250ZXh0Iiwic2NoZW1hTmFtZSIsImNvbm5lY3RvciIsImxvZ2dlciIsIm1vZGVsUGF0aCIsInNjcmlwdFNvdXJjZVBhdGgiLCJkYlNjcmlwdFBhdGgiLCJqb2luIiwiZHJpdmVyIiwiZGF0YWJhc2UiLCJyZXNldF8iLCJleGVjdXRlXyIsImNyZWF0ZURhdGFiYXNlIiwiY3JlYXRlXyIsInNxbEZpbGVzIiwicmVzdWx0Iiwid2FybmluZ1N0YXR1cyIsImxvZyIsImZpbGUiLCJzcWxGaWxlIiwiZXhpc3RzU3luYyIsIkVycm9yIiwic3FsIiwidHJpbSIsInJlYWRGaWxlU3luYyIsImVuY29kaW5nIiwiY2FzdEFycmF5IiwibXVsdGlwbGVTdGF0ZW1lbnRzIiwid2FybmluZ1Jvd3MiLCJyZWR1Y2UiLCJzdW0iLCJyb3ciLCJsb2FkXyIsImRhdGFGaWxlIiwiZXh0IiwiZXh0bmFtZSIsImRhdGEiLCJyZWFkSnNvblN5bmMiLCJjbGFzc05hbWUiLCJEYiIsImRiIiwiY29ubmVjdGlvblN0cmluZyIsIm9wdGlvbnMiLCJyZWNvcmRzIiwiZW50aXR5TmFtZSIsIk1vZGVsIiwibW9kZWwiLCJpdGVtcyIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiJHBrVmFsdWVzIiwiZXJyb3IiLCJjbG9zZV8iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUVBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQSxDQUFGO0FBQUtDLEVBQUFBLEVBQUw7QUFBU0MsRUFBQUEsVUFBVDtBQUFxQkMsRUFBQUE7QUFBckIsSUFBb0NKLE9B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XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgeyBfLCBmcywgZWFjaEFzeW5jXywgcGFzY2FsQ2FzZSB9ID0gcmVxdWlyZSgncmstdXRpbHMnKTtcblxuLyoqXG4gKiBNeVNRTCBtaWdyYXRpb24uXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgTXlTUUxNaWdyYXRpb24ge1xuICAgIC8qKiAgICAgXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0Nvbm5lY3Rvcn0gY29ubmVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSwgY29ubmVjdG9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gY29udGV4dC5sb2dnZXI7XG4gICAgICAgIHRoaXMubW9kZWxQYXRoID0gY29udGV4dC5tb2RlbFBhdGg7XG4gICAgICAgIHRoaXMuc2NyaXB0U291cmNlUGF0aCA9IGNvbnRleHQuc2NyaXB0U291cmNlUGF0aDtcbiAgICAgICAgdGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hTmFtZTtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XG5cbiAgICAgICAgdGhpcy5kYlNjcmlwdFBhdGggPSBwYXRoLmpvaW4odGhpcy5zY3JpcHRTb3VyY2VQYXRoLCB0aGlzLmNvbm5lY3Rvci5kcml2ZXIsIHRoaXMuY29ubmVjdG9yLmRhdGFiYXNlKTtcbiAgICB9XG5cbiAgICBhc3luYyByZXNldF8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5leGVjdXRlXyhgRFJPUCBEQVRBQkFTRSBJRiBFWElTVFMgPz9gLCBbIHRoaXMuY29ubmVjdG9yLmRhdGFiYXNlIF0sIHsgY3JlYXRlRGF0YWJhc2U6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlXygpIHsgICAgICAgIFxuICAgICAgICBsZXQgc3FsRmlsZXMgPSBbICdlbnRpdGllcy5zcWwnLCAncmVsYXRpb25zLnNxbCcsICdwcm9jZWR1cmVzLnNxbCcgXTtcbiAgICAgICAgXG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rvci5leGVjdXRlXygnQ1JFQVRFIERBVEFCQVNFIElGIE5PVCBFWElTVFMgPz8nLCBcbiAgICAgICAgICAgIFsgdGhpcy5jb25uZWN0b3IuZGF0YWJhc2UgXSwgXG4gICAgICAgICAgICB7IGNyZWF0ZURhdGFiYXNlOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQud2FybmluZ1N0YXR1cyA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2luZm8nLCBgQ3JlYXRlZCBkYXRhYmFzZSBcIiR7dGhpcy5jb25uZWN0b3IuZGF0YWJhc2V9XCIuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3dhcm4nLCBgRGF0YWJhc2UgXCIke3RoaXMuY29ubmVjdG9yLmRhdGFiYXNlfVwiIGV4aXN0cy5gKTtcbiAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIHJldHVybiBlYWNoQXN5bmNfKHNxbEZpbGVzLCBhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNxbEZpbGUgPSBwYXRoLmpvaW4odGhpcy5kYlNjcmlwdFBhdGgsIGZpbGUpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHNxbEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBzY3JpcHQgXCIke3NxbEZpbGV9XCIgbm90IGZvdW5kLiBUcnkgcnVuIFwib29sb25nIGJ1aWxkXCIgZmlyc3QuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzcWwgPSBfLnRyaW0oZnMucmVhZEZpbGVTeW5jKHNxbEZpbGUsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KSk7XG4gICAgICAgICAgICBpZiAoc3FsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5jYXN0QXJyYXkoYXdhaXQgdGhpcy5jb25uZWN0b3IuZXhlY3V0ZV8oc3FsLCBudWxsLCB7IG11bHRpcGxlU3RhdGVtZW50czogMSB9KSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgd2FybmluZ1Jvd3MgPSBfLnJlZHVjZShyZXN1bHQsIChzdW0sIHJvdykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gcm93Lndhcm5pbmdTdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAod2FybmluZ1Jvd3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygnd2FybicsIGAke3dhcm5pbmdSb3dzfSB3YXJuaW5nKHMpIHJlcG9ydGVkIHdoaWxlIHJ1bm5pbmcgXCIke2ZpbGV9XCIuYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdpbmZvJywgYERhdGFiYXNlIHNjcmlwdHMgXCIke3NxbEZpbGV9XCIgcnVuIHN1Y2Nlc3NmdWxseS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRfKGRhdGFGaWxlKSB7XG4gICAgICAgIGxldCBleHQgPSBwYXRoLmV4dG5hbWUoZGF0YUZpbGUpO1xuXG4gICAgICAgIGlmIChleHQgPT09ICcuanNvbicpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZnMucmVhZEpzb25TeW5jKGRhdGFGaWxlLCB7ZW5jb2Rpbmc6ICd1dGY4J30pO1xuXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gcGFzY2FsQ2FzZSh0aGlzLnNjaGVtYU5hbWUpO1xuICAgICAgICAgICAgbGV0IERiID0gcmVxdWlyZShwYXRoLmpvaW4odGhpcy5tb2RlbFBhdGgsIGNsYXNzTmFtZSkpO1xuICAgICAgICAgICAgbGV0IGRiID0gbmV3IERiKHRoaXMuY29ubmVjdG9yLmNvbm5lY3Rpb25TdHJpbmcsIHRoaXMuY29ubmVjdG9yLm9wdGlvbnMpOyAgICAgICAgICAgIFxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiLmNvbm5lY3Rvci5leGVjdXRlXygnU0VUIEZPUkVJR05fS0VZX0NIRUNLUz0wOycpO1xuXG4gICAgICAgICAgICAgICAgYXdhaXQgZWFjaEFzeW5jXyhkYXRhLCBhc3luYyAocmVjb3JkcywgZW50aXR5TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgTW9kZWwgPSBkYi5tb2RlbChlbnRpdHlOYW1lKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gQXJyYXkuaXNBcnJheShyZWNvcmRzKSA/IHJlY29yZHMgOiBbIHJlY29yZHMgXTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWFjaEFzeW5jXyhpdGVtcywgYXN5bmMgaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kZWwgPSBhd2FpdCBNb2RlbC5jcmVhdGVfKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCd2ZXJib3NlJywgYENyZWF0ZWQgYShuKSAke2VudGl0eU5hbWV9IGVudGl0eTogJHtKU09OLnN0cmluZ2lmeShtb2RlbC4kcGtWYWx1ZXMpfWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGF3YWl0IGRiLmNvbm5lY3Rvci5leGVjdXRlXygnU0VUIEZPUkVJR05fS0VZX0NIRUNLUz0xOycpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIuY2xvc2VfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0ID09PSAnLnNxbCcpIHtcbiAgICAgICAgICAgIGxldCBzcWwgPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUZpbGUsIHtlbmNvZGluZzogJ3V0ZjgnfSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0b3IuZXhlY3V0ZV8oc3FsLCBudWxsLCB7IG11bHRpcGxlU3RhdGVtZW50czogMSB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygndmVyYm9zZScsIGBFeGVjdXRlZCBTUUwgZmlsZTogJHtkYXRhRmlsZX1gLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIGZpbGUgZm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE15U1FMTWlncmF0aW9uOyJdfQ==